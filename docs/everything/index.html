<!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Handbook Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="../css/handbook.css" />
        <script src="../js/handbook.js"></script>
    </head>
    <body class="dark-light">
        <div class="theme-selector">
            Theme:
            <div id="set-theme-light">■</div>
            <div id="set-theme-dark">■</div>
            <div id="set-theme-dark-light">■</div>
            <div id="set-theme-light-dark">■</div>
        </div>
    <article>
    <h1 id="typescript-basics"><a href="#typescript-basics">TypeScript Basics</h1></a>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#static-type-checking">Static type-checking</a></li><li><a href="#non-exception-failures">Non-exception Failures</a></li><li><a href="#types-for-tooling">Types for Tooling</a></li><li><a href="#tsc,-the-typescript-compiler"><code>tsc</code>, the TypeScript compiler</a></li><ul><li><a href="#emitting-with-errors">Emitting with Errors</a></li></ul><li><a href="#explicit-types">Explicit Types</a></li><li><a href="#erased-types">Erased Types</a></li><li><a href="#downleveling">Downleveling</a></li><li><a href="#strictness">Strictness</a></li><ul><li><a href="#noimplicitany"><code>noImplicitAny</code></a></li><li><a href="#strictnullchecks"><code>strictNullChecks</code></a></li></ul></ul></ul></div>
<p>Each and every value in JavaScript has a set of behaviors you can observe from running different operations.
That sounds abstract, but as a quick example, consider some operations we might run on a variable named <code>foo</code>.</p>
<p><pre class="typescript-code"><span class="tm-cmt">// accessing the property 'toLowerCase'</span>
<span class="tm-cmt">// on 'foo' and then calling it</span>
<span class="tm-vr">foo</span>.<span class="tm-mth">toLowerCase</span>();

<span class="tm-cmt">// calling 'foo'</span>
<span class="tm-mth">foo</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20accessing%20the%20property%20'toLowerCase'%0A%2F%2F%20on%20'foo'%20and%20then%20calling%20it%0Afoo.toLowerCase()%3B%0A%0A%2F%2F%20calling%20'foo'%0Afoo()%3B">Try</a></pre></p>
<p>If we break this down, the first runnable line of code accesses a property called <code>toLowerCase</code> and then calls it.
The second one tries to call <code>foo</code> directly.</p>
<p>But assuming we don't know the value of <code>foo</code> - and that's pretty common - we can't reliably say what results we'll get from trying to run any of this code.
The behavior of each operation depends entirely on what what value we had in the first place.
Is <code>foo</code> callable?
Does it have a property called <code>toLowerCase</code> on it?
And if it does, is <code>toLowerCase</code> callable?
If all of these values are callable, what do they return?
The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.</p>
<p>Let's say <code>foo</code> was defined in the following way.</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">foo</span> = <span class="tm-str">"Hello World!"</span>;</pre></p>
<p>As you can probably guess, if we try to run <code>foo.toLowerCase()</code>, we'll get the same string, but completely in lower-case letters.</p>
<p>What about that second line of code?
If you're familiar with JavaScript, you'll know this fails with an exception:</p>
<pre><code class="txt language-txt">TypeError: foo is not a function
</code></pre>
<p>It'd be great if we could avoid mistakes like this.
When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the <em>type</em> of the value - what sorts of behaviors and capabilities it has.
That's part of what that <code>TypeError</code> is alluding to - it's saying that there's nothing to call on the string <code>"Hello World"</code>.</p>
<p>For some values, such as the primitives <code>string</code> and <code>number</code>, we can identify their type at runtime using the <code>typeof</code> operator.
But for other things like functions, there's no corresponding runtime mechanism to identify their types.
For example, consider this function:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>) {
    <span class="tm-kw">return</span> <span class="tm-vr">x</span>.<span class="tm-mth">flip</span>();
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fn(x)%20%7B%0A%20%20%20%20return%20x.flip()%3B%0A%7D">Try</a></pre></p>
<p>We can <em>observe</em> by reading the code that this function will only work if given an object with a callable <code>flip</code> property, but JavaScript doesn't surface this information in a way that we can check while the code is running.
The only way in pure JavaScript to tell what <code>fn</code> does with a particular value is to call it and see what happens.
This kind of behavior makes it hard to predict what code will do before it runs, which means it's harder to know what your code is going to do while you're writing it.</p>
<p>Seen in this way, a <em>type</em> is the concept of describing which values are legal to pass to <code>fn</code> and which aren't legal.
JavaScript only truly provides <em>dynamic</em> typing - running the code to see what happens.</p>
<p>The alternative is to use a <em>static</em> type system to make predictions about what code is legal <em>before</em> it runs.</p>
<h2 id="static-type-checking"><a href="#static-type-checking">Static type-checking</h2></a>
<p>Think back to that <code>TypeError</code> we got earlier from calling a <code>string</code>.
<em>Most people</em> don't like to get any sorts of errors when running their code - those are considered bugs!
And when we write new code, we try our best to avoid introducing new bugs.</p>
<p>If we add just a bit of code, save our file, refresh our app, and immediately see the error, we might be able to isolate the problem quickly; but that's not always the case.
We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown!
Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we're forced to dig through.</p>
<p>Ideally, we could have a tool that helps us find these bugs <em>before</em> our code runs.
That's what a static type-checker like TypeScript does.
<em>Static types systems</em> describe the shapes and behaviors of what our values will be when we run our programs.
A type-checker like TypeScript uses that information and tells us when things might be going off the rails.</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">foo</span> = <span class="tm-str">"hello!"</span>;

<span class="error" tabindex="0" aria-describedby="errLabel-2349-21-5"><span class="error-highlight"></span><span class="tm-mth">foo</span>()<span id="errLabel-2349-21-5" role="tooltip" class="error-tooltip">Cannot invoke an expression whose type lacks a call signature. Type 'String' has no compatible call signatures.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Cannot invoke an expression whose type lacks a call signature. Type 'String' has no compatible call signatures.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20foo%20%3D%20%22hello!%22%3B%0A%0Afoo()%3B">Try</a></pre></p>
<p>Running that last sample with TypeScript will give us an error message before we run the code in the first place.</p>
<h2 id="non-exception-failures"><a href="#non-exception-failures">Non-exception Failures</h2></a>
<p>So far we've been discussing certain things like runtime errors - cases where the JavaScript runtime throws its hands up and tells us that it thinks something is nonsensical.
Those cases come up because <a href="https://tc39.github.io/ecma262/">the ECMAScript specification</a> has explicit instructions on how the language should behave when it runs into something unexpected.</p>
<p>For example, the specification says that trying to call something that isn't callable should throw an error.
Maybe that sounds like "obvious behavior", but you could imagine that accessing a property that doesn't exist on an object should throw an error too.
Instead, JavaScript gives us different behavior and returns the value <code>undefined</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">foo</span> = {
    <span class="tm-vr">name:</span> <span class="tm-str">"Daniel"</span>,
    <span class="tm-vr">age:</span> <span class="tm-num">26</span>,
};

<span class="tm-vr">foo</span>.<span class="tm-vr">location</span>; <span class="tm-cmt">// returns undefined</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20foo%20%3D%20%7B%0A%20%20%20%20name%3A%20%22Daniel%22%2C%0A%20%20%20%20age%3A%2026%2C%0A%7D%3B%0A%0Afoo.location%3B%20%2F%2F%20returns%20undefined">Try</a></pre></p>
<p>Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it's "valid" JavaScript that won't immediately throw an error.
In TypeScript, the following code produces an error about <code>location</code> not being defined:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">foo</span> = {
    <span class="tm-vr">name:</span> <span class="tm-str">"Daniel"</span>,
    <span class="tm-vr">age:</span> <span class="tm-num">26</span>,
};

<span class="tm-vr">foo</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2339-53-8"><span class="error-highlight"></span><span class="tm-vr">location</span><span id="errLabel-2339-53-8" role="tooltip" class="error-tooltip">Property 'location' does not exist on type '{ name: string; age: number; }'.</span></span>; <span class="tm-cmt">// returns undefined</span><hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'location' does not exist on type '{ name: string; age: number; }'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20foo%20%3D%20%7B%0A%20%20%20%20name%3A%20%22Daniel%22%2C%0A%20%20%20%20age%3A%2026%2C%0A%7D%3B%0A%0Afoo.location%3B%20%2F%2F%20returns%20undefined">Try</a></pre></p>
<p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs.
And TypeScript catches <em>a lot</em> of legitimate bugs.
For example: typos,</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">someString</span> = <span class="tm-str">"Hello World!"</span>;

<span class="tm-cmt">// How quickly can you spot the typos?</span>
<span class="tm-vr">someString</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2551-84-17"><span class="error-highlight"></span><span class="tm-mth">toLocaleLowercase</span><span id="errLabel-2551-84-17" role="tooltip" class="error-tooltip">Property 'toLocaleLowercase' does not exist on type 'string'. Did you mean 'toLocaleLowerCase'?</span></span>();
<span class="tm-vr">someString</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2551-116-16"><span class="error-highlight"></span><span class="tm-mth">toLocalLowerCase</span><span id="errLabel-2551-116-16" role="tooltip" class="error-tooltip">Property 'toLocalLowerCase' does not exist on type 'string'. Did you mean 'toLocaleLowerCase'?</span></span>();

<span class="tm-cmt">// We probably meant to write this...</span>
<span class="tm-vr">someString</span>.<span class="tm-mth">toLocaleLowerCase</span>();<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'toLocaleLowercase' does not exist on type 'string'. Did you mean 'toLocaleLowerCase'?</div></div><div class="listed-error"><div class="error-line">Property 'toLocalLowerCase' does not exist on type 'string'. Did you mean 'toLocaleLowerCase'?</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20someString%20%3D%20%22Hello%20World!%22%3B%0A%0A%2F%2F%20How%20quickly%20can%20you%20spot%20the%20typos%3F%0AsomeString.toLocaleLowercase()%3B%0AsomeString.toLocalLowerCase()%3B%0A%0A%2F%2F%20We%20probably%20meant%20to%20write%20this...%0AsomeString.toLocaleLowerCase()%3B">Try</a></pre></p>
<p>uncalled functions,</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">flipCoin</span>() {
    <span class="tm-kw">return</span> <span class="error" tabindex="0" aria-describedby="errLabel-2365-33-17"><span class="error-highlight"></span><span class="tm-typ">Math</span>.<span class="tm-mth">random</span> < <span class="tm-num">0.5</span><span id="errLabel-2365-33-17" role="tooltip" class="error-tooltip">Operator '&lt;' cannot be applied to types '() => number' and 'number'.</span></span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Operator '&lt;' cannot be applied to types '() => number' and 'number'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20flipCoin()%20%7B%0A%20%20%20%20return%20Math.random%20%3C%200.5%3B%0A%7D">Try</a></pre></p>
<p>or basic logic errors.</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">value</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() < <span class="tm-num">0.5</span> ? <span class="tm-str">"a"</span> : <span class="tm-str">"b"</span>;
<span class="tm-kw">if</span> (<span class="tm-vr">value</span> !== <span class="tm-str">"a"</span>) {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="error" tabindex="0" aria-describedby="errLabel-2367-88-13"><span class="error-highlight"></span><span class="tm-vr">value</span> === <span class="tm-str">"b"</span><span id="errLabel-2367-88-13" role="tooltip" class="error-tooltip">This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.</span></span>) {
  <span class="tm-cmt">// Oops, unreachable</span>
}<hr class="error-divider"><div class="listed-error"><div class="error-line">This condition will always return 'false' since the types '"a"' and '"b"' have no overlap.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=const%20value%20%3D%20Math.random()%20%3C%200.5%20%3F%20%22a%22%20%3A%20%22b%22%3B%0Aif%20(value%20!%3D%3D%20%22a%22)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0Aelse%20if%20(value%20%3D%3D%3D%20%22b%22)%20%7B%0A%20%20%2F%2F%20Oops%2C%20unreachable%0A%7D">Try</a></pre></p>
<h2 id="types-for-tooling"><a href="#types-for-tooling">Types for Tooling</h2></a>
<!-- TODO: this section's title sucks -->
<p>TypeScript can catch bugs when we make mistakes in our code.
That's great, but TypeScript can <em>also</em> prevent us from making those mistakes in the first place.</p>
<p>The type-checker has information to check things like whether we're accessing the right properties on variables and other properties.
Once it has that information, it can also start <em>suggesting</em> which properties you might want to use.</p>
<p>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor.
That's part of what people often refer to when they talk about tooling in TypeScript.</p>
<!-- TODO: insert GIF of completions here -->
<p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type.
An editor that supports TypeScript can deliver "quick fixes" to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable.
All of this is built on top of the type-checker and fully cross-platform, so it's likely that <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support">your favorite editor has TypeScript support available</a>.</p>
<!-- TODO: validate that link -->
<h2 id="tsc-the-typescript-compiler"><a href="#tsc-the-typescript-compiler"><code>tsc</code>, the TypeScript compiler</h2></a>
<p>We've been talking about type-checking, but we haven't yet used our type-<em>checker</em>.
Let's get acquainted with our new friend <code>tsc</code>, the TypeScript compiler.
First we'll need to grab it via npm.</p>
<pre><code class="sh language-sh">npm install -g typescript
</code></pre>
<blockquote>
  <p>This installs the TypeScript Compiler <code>tsc</code> globally.
  You can use <code>npx</code> or similar tools if you'd prefer to run <code>tsc</code> from a local <code>node_modules</code> package instead.</p>
</blockquote>
<p>Now let's move to an empty folder and try writing our first TypeScript program: <code>hello.ts</code>:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Greets the world.</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello world!"</span>);</pre></p>
<p>Notice there are no frills here; this "hello world" program looks identical to what you'd write for a "hello world" program in JavaScript.
And now let's type-check it by running the command <code>tsc</code> which was installed for us by the <code>typescript</code> package.</p>
<pre><code class="sh language-sh">tsc hello.ts
</code></pre>
<p>Tada!</p>
<p>Wait, "tada" <em>what</em> exactly?
We ran <code>tsc</code> and nothing happened!
Well, there were no type errors, so we didn't get any output in our console since there was nothing to report.</p>
<p>But check again - we got some <em>file</em> output instead.
If we look in our current directory, we'll see a <code>hello.js</code> file next to <code>hello.ts</code>.
That's the output from our <code>hello.ts</code> file after <code>tsc</code> <em>compiles</em> or <em>transforms</em> it into a JavaScript file.
And if we check the contents, we'll see what TypeScript spits out after it processes a <code>.ts</code> file:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Greets the world.</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello world!"</span>);</pre></p>
<p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote.
The compiler tries to emit clean readable code that looks like something a person would write.
While that's not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.</p>
<p>What about if we <em>did</em> introduce a type-checking error?
Let's rewrite <code>hello.ts</code>:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// This is an industrial-grade general-purpose greeter function:</span>
<span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>, <span class="tm-vr">date</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-kw">}</span><span class="tm-str">!`</span>);
}

<span class="error" tabindex="0" aria-describedby="errLabel-2554-154-16"><span class="error-highlight"></span><span class="tm-mth">greet</span>(<span class="tm-str">"Brendan"</span>)<span id="errLabel-2554-154-16" role="tooltip" class="error-tooltip">Expected 2 arguments, but got 1.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Expected 2 arguments, but got 1.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20This%20is%20an%20industrial-grade%20general-purpose%20greeter%20function%3A%0Afunction%20greet(person%2C%20date)%20%7B%0A%20%20%20%20console.log(%60Hello%20%24%7Bperson%7D%2C%20today%20is%20%24%7Bdate%7D!%60)%3B%0A%7D%0A%0Agreet(%22Brendan%22)%3B">Try</a></pre></p>
<p>If we run <code>tsc hello.ts</code> again, notice that we get an error on the command line!</p>
<pre><code class="txt language-txt">Expected 2 arguments, but got 1.
</code></pre>
<p>TypeScript is telling us we forgot to pass an argument to the <code>greet</code> function, and rightfully so.
So far we've only written standard JavaScript, and yet type-checking was still able to find problems with our code.
Thanks TypeScript!</p>
<h3 id="emitting-with-errors"><a href="#emitting-with-errors">Emitting with Errors</h3></a>
<p>One thing you might not have noticed from the last example was that our <code>hello.js</code> file changed again.
If we open that file up then we'll see that the contents still basically look the same as our input file.
That might be a bit surprising given the fact that <code>tsc</code> reported an error about our code, but this based on one of TypeScript's core values: much of the time, <em>you</em> will know better than TypeScript.</p>
<p>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there's a tradeoff on what sorts of things a type-checker finds acceptable.
Most of the time that's okay, but there are scenarios where those checks get in the way.
For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors.
Eventually you'll get around to cleaning things up for the type-checker, but that original JavaScript code was already working!
Why should converting it over to TypeScript stop you from running it?</p>
<p>So TypeScript doesn't get in your way.
Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly.
In that case, you can use the <code>--noEmitOnError</code> compiler option.
Try changing your <code>hello.ts</code> file and running <code>tsc</code> with that flag:</p>
<pre><code class="sh language-sh">tsc --noEmitOnError hello.ts
</code></pre>
<p>You'll notice that <code>hello.js</code> never gets updated.</p>
<h2 id="explicit-types"><a href="#explicit-types">Explicit Types</h2></a>
<p>Up until now, we haven't told TypeScript what <code>person</code> or <code>date</code> are.
Let's change up our code a little bit so that we tell TypeScript that <code>person</code> is a <code>string</code>, and that <code>date</code> should be a <code>Date</code> object.
We'll also use the <code>toDateString()</code> method on <code>date</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>: <span class="tm-typ">string</span>, <span class="tm-vr">date</span>: <span class="tm-typ"><span class="interfaceName">Date</span></span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-str">.</span><span class="tm-mth">toDateString</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">!`</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(person%3A%20string%2C%20date%3A%20Date)%20%7B%0A%20%20%20%20console.log(%60Hello%20%24%7Bperson%7D%2C%20today%20is%20%24%7Bdate.toDateString()%7D!%60)%3B%0A%7D">Try</a></pre></p>
<p>What we did was add <em>type annotations</em> on <code>person</code> and <code>date</code> to describe what types of values <code>greet</code> can be called with.
You can read that signature as "<code>greet</code> takes a <code>person</code> of type <code>string</code>, and a <code>date</code> of type <code>Date</code>".</p>
<p>With this, TypeScript can tell us about other cases where we might have been called incorrectly.
For example…</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>: <span class="tm-typ">string</span>, <span class="tm-vr">date</span>: <span class="tm-typ"><span class="interfaceName">Date</span></span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-str">.</span><span class="tm-mth">toDateString</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">!`</span>);
}

<span class="tm-mth">greet</span>(<span class="tm-str">"Maddison"</span>, <span class="error" tabindex="0" aria-describedby="errLabel-2345-136-6"><span class="error-highlight"></span><span class="tm-typ">Date</span>()<span id="errLabel-2345-136-6" role="tooltip" class="error-tooltip">Argument of type 'string' is not assignable to parameter of type 'Date'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'string' is not assignable to parameter of type 'Date'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(person%3A%20string%2C%20date%3A%20Date)%20%7B%0A%20%20%20%20console.log(%60Hello%20%24%7Bperson%7D%2C%20today%20is%20%24%7Bdate.toDateString()%7D!%60)%3B%0A%7D%0A%0Agreet(%22Maddison%22%2C%20Date())%3B">Try</a></pre></p>
<p>Huh?
TypeScript reported an error on our second argument, but why?</p>
<p>Perhaps surprisingly, calling <code>Date()</code> in JavaScript returns a <code>string</code>.
On the other hand, constructing a <code>Date</code> with <code>new Date()</code> actually gives us what we were expecting.</p>
<p>Anyway, we can quickly fix up the error:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>: <span class="tm-typ">string</span>, <span class="tm-vr">date</span>: <span class="tm-typ"><span class="interfaceName">Date</span></span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-str">.</span><span class="tm-mth">toDateString</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">!`</span>);
}

<span class="tm-mth">greet</span>(<span class="tm-str">"Maddison"</span>, <span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span><span class="tm-kw">new</span> <span class="tm-typ">Date</span>()</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(person%3A%20string%2C%20date%3A%20Date)%20%7B%0A%20%20%20%20console.log(%60Hello%20%24%7Bperson%7D%2C%20today%20is%20%24%7Bdate.toDateString()%7D!%60)%3B%0A%7D%0A%0Agreet(%22Maddison%22%2C%20new%20Date())%3B">Try</a></pre></p>
<p>Keep in mind, we don't always have to write explicit type annotations.
In many cases, TypeScript can even just <em>infer</em> (or "figure out") the types for us even if we omit them.</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">foo</span> = <span class="tm-str">"hello there!"</span>
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">foo</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span></pre></p>
<p>Even though we didn't tell TypeScript that <code>foo</code> had the type <code>string</code> it was able to figure that out.
That's a feature, and it's best not to add annotations when the type system would end up inferring the same type anyway.</p>
<h2 id="erased-types"><a href="#erased-types">Erased Types</h2></a>
<p>Let's take a look at what happens when we compile with <code>tsc</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>, <span class="tm-vr">date</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello "</span> + <span class="tm-vr">person</span> + <span class="tm-str">", today is "</span> + <span class="tm-vr">date</span>.<span class="tm-mth">toDateString</span>() + <span class="tm-str">"!"</span>);
}
<span class="tm-mth">greet</span>(<span class="tm-str">"Maddison"</span>, <span class="tm-kw">new</span> <span class="tm-typ">Date</span>());<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(person%2C%20date)%20%7B%0A%20%20%20%20console.log(%22Hello%20%22%20%2B%20person%20%2B%20%22%2C%20today%20is%20%22%20%2B%20date.toDateString()%20%2B%20%22!%22)%3B%0A%7D%0Agreet(%22Maddison%22%2C%20new%20Date())%3B">Try</a></pre></p>
<p>Notice two things here:</p>
<ol>
<li>Our <code>person</code> and <code>date</code> parameters no longer have type annotations.</li>
<li>Our "template string" - that string that used backticks (the <code>`</code> character - was converted to plain strings with concatenations (<code>+</code>).</li>
</ol>
<p>More on that second point later, but let's now focus on that first point.
Type annotations aren't part of JavaScript (or ECMAScript to be pedantic), so there really aren't any browsers or other runtimes that can just run TypeScript unmodified.
That's why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it.
Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</p>
<blockquote>
  <p><strong>Remember</strong>: Type annotations never change the runtime behavior of your program.</p>
</blockquote>
<h2 id="downleveling"><a href="#downleveling">Downleveling</h2></a>
<p>One other difference from the above was that our template string was rewritten from</p>
<p><pre class="typescript-code"><span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-str">.</span><span class="tm-mth">toDateString</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">!`</span></pre></p>
<p>to</p>
<p><pre class="typescript-code"><span class="tm-str">"Hello "</span> + <span class="tm-vr">person</span> + <span class="tm-str">", today is "</span> + <span class="tm-vr">date</span>.<span class="tm-mth">toDateString</span>() + <span class="tm-str">"!"</span></pre></p>
<p>Why did this happen?</p>
<p>Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - don't ask).
TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5).
This process from moving from a newer or "higher" version of ECMAScript to an older or "lower" one is sometimes called <em>downleveling</em>.</p>
<p>By default TypeScript targets ES3, an extremely old version of ECMAScript.
We could have chosen something a little bit more recent by using the <code>--target</code> flag.
Running with <code>--target es2015</code> changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported.
So running <code>tsc --target es2015 input.ts</code> gives us the following output:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">person</span>, <span class="tm-vr">date</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello </span><span class="tm-kw">${</span><span class="tm-vr">person</span><span class="tm-kw">}</span><span class="tm-str">, today is </span><span class="tm-kw">${</span><span class="tm-vr">date</span><span class="tm-str">.</span><span class="tm-mth">toDateString</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">!`</span>);
}
<span class="tm-mth">greet</span>(<span class="tm-str">"Maddison"</span>, <span class="tm-kw">new</span> <span class="tm-typ">Date</span>());<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(person%2C%20date)%20%7B%0A%20%20%20%20console.log(%60Hello%20%24%7Bperson%7D%2C%20today%20is%20%24%7Bdate.toDateString()%7D!%60)%3B%0A%7D%0Agreet(%22Maddison%22%2C%20new%20Date())%3B">Try</a></pre></p>
<blockquote>
  <p>While the default target is ES3, the great majority of running browsers support ES5.
  Today, most developers can safely specify ES5 or even ES2016 as a target unless compatibility with certain ancient browers is important.</p>
</blockquote>
<h2 id="strictness"><a href="#strictness">Strictness</h2></a>
<p>Users come to TypeScript looking for different things in a type-checker.
Some people are looking for a more loose opt-in experience which can help validate only some parts of our program and give us decent tooling.
This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there's no checking for potentially <code>null</code>/<code>undefined</code> values.
Much like how <code>tsc</code> emits in the face of errors, these defaults are put in place to stay out of your way.
If you're migrating existing JavaScript, that might be desirable.</p>
<p>In contrast, a lot of users prefer to have TypeScript validate as much as it can off the bat, and that's why the language provides strictness settings as well.
These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial.
The farther you turn this dial up, the more TypeScript will check for you.
This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling.
If possible, a new codebase should always turn these strictness checks on.</p>
<p>TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated.
The <code>--strict</code> flag toggles them all on simultaneously, but we can opt out of them individually.
The two biggest ones you should know about are <code>noImplicitAny</code> and <code>strictNullChecks</code>.</p>
<h3 id="noimplicitany"><a href="#noimplicitany"><code>noImplicitAny</code></h3></a>
<p>Recall that in some places, TypeScript doesn't try to infer any types for us and instead falls back to the most lenient type: <code>any</code>.
This isn't the worst thing that can happen - after all, falling back to <code>any</code> is just the JavaScript experience anyway.</p>
<p>However, using <code>any</code> often defeats the purpose of using TypeScript in the first place.
The more typed your program is, the more validation and tooling you'll get, meaning you'll run into fewer bugs as you code.
Turning on the <code>noImplicitAny</code> flag will issue an error on any variables whose type is implicitly inferred as <code>any</code>.</p>
<h3 id="strictnullchecks"><a href="#strictnullchecks"><code>strictNullChecks</code></h3></a>
<p>By default, values like <code>null</code> and <code>undefined</code> are assignable to any other type.
This can make writing some code easier, but forgetting to handle <code>null</code> and <code>undefined</code> is the cause of countless bugs in the world - not even just JavaScript!</p>
<p>The <code>strictNullChecks</code> flag makes handling <code>null</code> and <code>undefined</code> more explicit, and <em>spares</em> us from worrying about whether we <em>forgot</em> to handle <code>null</code> and <code>undefined</code>.</p><hr><!-- Extremely WIP, do not review -->
<h1 id="everyday-types"><a href="#everyday-types">Everyday Types</h1></a>
<p>In this chapter, we'll cover some of the most common types of values you'll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript.
This isn't an exhaustive list, and future chapters will describe more ways to name and use other types.</p>
<p>Types can also appear in many more <em>places</em> than just type annotations.
As we learn about the types themselves, we'll also learn about the places where we can refer to these types to form new constructs.</p>
<p>We'll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code.
These will later form the core "building blocks" of more complex types.</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#primitives-string,-number,-and-boolean">Primitives <code>string</code>, <code>number</code>, and <code>boolean</code></a></li><li><a href="#arrays">Arrays</a></li><li><a href="#any"><code>any</code></a></li><ul><li><a href="#noimplicitany"><code>noImplicitAny</code></a></li></ul><li><a href="#type-annotations-on-variables">Type Annotations on Variables</a></li><li><a href="#functions">Functions</a></li><ul><li><a href="#parameter-type-annotations">Parameter Type Annotations</a></li><li><a href="#return-type-annotations">Return Type Annotations</a></li><li><a href="#function-expressions">Function Expressions</a></li></ul><li><a href="#object-types">Object Types</a></li><ul><li><a href="#optional-properties">Optional Properties</a></li></ul><li><a href="#union-types">Union Types</a></li><ul><li><a href="#defining-a-union-type">Defining a Union Type</a></li><li><a href="#working-with-union-types">Working with Union Types</a></li></ul><li><a href="#type-aliases">Type Aliases</a></li><li><a href="#interfaces">Interfaces</a></li><ul><li><a href="#interface-vs-alias">Differences Between Type Aliases and Interfaces</a></li></ul><li><a href="#type-assertions">Type Assertions</a></li><li><a href="#literal-types">Literal Types</a></li><ul><li><a href="#literal-inference">Literal Inference</a></li></ul><li><a href="#null-and-undefined"><code>null</code> and <code>undefined</code></a></li><ul><li><a href="#strictnullchecks-off"><code>strictNullChecks</code> off</a></li><li><a href="#strictnullchecks-on"><code>strictNullChecks</code> on</a></li><li><a href="#non-null-operator">Non-null Assertion Operator (Postfix <code>!</code>)</a></li></ul></ul></ul></div>
<h2 id="primitives-string-number-and-boolean"><a href="#primitives-string-number-and-boolean">Primitives <code>string</code>, <code>number</code>, and <code>boolean</code></h2></a>
<p>JavaScript has three main <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitive</a> kinds of values: <code>string</code>, <code>number</code>, and <code>boolean</code>.
Each has a corresponding type in TypeScript.
As you might expect, these are the same names you'd see if you used the JavaScript <code>typeof</code> operator on a value of those types:</p>
<ul>
<li><code>string</code> represents string values like <code>"Hello, world"</code></li>
<li><code>number</code> is for numbers like <code>42</code>. JavaScript does not have a special runtime value for integers, so there's no equivalent to <code>int</code> or <code>float</code> - everything is simply <code>number</code></li>
<li><code>boolean</code> is for the two values <code>true</code> and <code>false</code></li>
</ul>
<blockquote>
  <p>The type names <code>String</code>, <code>Number</code>, and <code>Boolean</code> (starting with capital letters) are legal, but refer to some special built-in types that shouldn't appear in your code. <em>Always</em> use <code>string</code>, <code>number</code>, or <code>boolean</code>.</p>
</blockquote>
<h2 id="arrays"><a href="#arrays">Arrays</h2></a>
<p>To specify the type of an array like <code>[1, 2, 3]</code>, you can use the syntax <code>number[]</code>; this syntax works for any type (e.g. <code>string[]</code> is an array of strings, and so on).
You may also see this written as <code>Array&lt;number&gt;</code>, which means the same thing.
We'll learn more about the syntax <code>T&lt;U&gt;</code> when we cover <em>generics</em>.</p>
<blockquote>
  <p>Note that <code>[number]</code> is a different thing; refer to the section on <em>tuple types</em>.</p>
</blockquote>
<h2 id="any"><a href="#any"><code>any</code></h2></a>
<p>TypeScript also has a special type, <code>any</code>, that you can use whenever you don't want a particular value to cause typechecking errors.</p>
<p>When a value is of type <code>any</code>, you can access any properties of it (which will in turn be of type <code>any</code>), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that's syntactically legal:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">obj</span>: <span class="tm-typ">any</span> = { <span class="tm-vr">x:</span> <span class="tm-num">0</span> };
<span class="tm-cmt">// None of these lines of code are errors</span>
<span class="tm-vr">obj</span>.<span class="tm-mth">foo</span>();
<span class="tm-mth">obj</span>();
<span class="tm-vr">obj</span>.<span class="tm-vr">bar</span> = <span class="tm-num">100</span>;
<span class="tm-vr">obj</span> = <span class="tm-str">"hello"</span>;
<span class="tm-kw">const</span> <span class="tm-vr">n</span>: <span class="tm-typ">number</span> = <span class="tm-vr">obj</span>;<a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20obj%3A%20any%20%3D%20%7B%20x%3A%200%20%7D%3B%0A%2F%2F%20None%20of%20these%20lines%20of%20code%20are%20errors%0Aobj.foo()%3B%0Aobj()%3B%0Aobj.bar%20%3D%20100%3B%0Aobj%20%3D%20%22hello%22%3B%0Aconst%20n%3A%20number%20%3D%20obj%3B">Try</a></pre></p>
<p>The <code>any</code> type is useful when you don't want to write out a long type just to convince TypeScript that a particular line of code is okay.</p>
<h3 id="noimplicitany"><a href="#noimplicitany"><code>noImplicitAny</code></h3></a>
<p>When a type isn't specified and can't be inferred from context, TypeScript will typically default to <code>any</code>.
Because <code>any</code> values don't benefit from type-checking, it's usually desirable to avoid these situations.
The compiler flag <code>noImplicitAny</code> will cause any <em>implicit</em> <code>any</code> to be flagged as an error.</p>
<h2 id="type-annotations-on-variables"><a href="#type-annotations-on-variables">Type Annotations on Variables</h2></a>
<p>When you declare a variable using <code>const</code>, <code>var</code>, or <code>let</code>, you can optionally add a type annotation to explicitly specify the type of the variable:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">myName</span><span class="highlight"><span class="highlight-content"></span><span class="highlight-description">Type annotation</span>: <span class="tm-typ">string</span></span> = <span class="tm-str">"Alice"</span>;</pre></p>
<blockquote>
  <p>TypeScript doesn't use "types on the left"-style declarations like <code>int x = 0;</code>
  Type annotations will always go <em>after</em> the thing being typed.</p>
</blockquote>
<p>In most cases, though, this isn't needed.
Wherever possible, TypeScript tries to automatically <em>infer</em> the types in your code.
For example, the type of a variable is inferred based on the type of its initializer:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// No type annotation needed -- 'myName' inferred as type 'string'</span>
<span class="tm-kw">let</span> <span class="tm-vr">myName</span> = <span class="tm-str">"Alice"</span>;</pre></p>
<p>For the most part you don't need to explicitly learn the rules of inference.
If you're starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what's going on.</p>
<h2 id="functions"><a href="#functions">Functions</h2></a>
<p>Functions are the primary means of passing data around in JavaScript.
TypeScript allows you to specify the types of both the input and output values of functions.</p>
<h3 id="parameter-type-annotations"><a href="#parameter-type-annotations">Parameter Type Annotations</h3></a>
<p>When you declare a function, you can add type annotations after each parameter to declare what kinds of parameters the function accepts.
Parameter type annotations go after the parameter name:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Parameter type annotation</span>
<span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">name</span><span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span>: <span class="tm-typ">string</span></span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-vr">name</span>.<span class="tm-mth">toUpperCase</span>() + <span class="tm-str">"!!"</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Parameter%20type%20annotation%0Afunction%20greet(name%3A%20string)%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20name.toUpperCase()%20%2B%20%22!!%22)%3B%0A%7D">Try</a></pre></p>
<p>When a parameter has a type annotation, calls to that function will be validated:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// Would be a runtime error if executed!</span>
<span class="tm-mth">greet</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-97-2"><span class="error-highlight"></span><span class="tm-num">42</span><span id="errLabel-2345-97-2" role="tooltip" class="error-tooltip">Argument of type '42' is not assignable to parameter of type 'string'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '42' is not assignable to parameter of type 'string'.</div></div></pre></p>
<h3 id="return-type-annotations"><a href="#return-type-annotations">Return Type Annotations</h3></a>
<p>You can also add return type annotations.
Return type annotations appear after the parameter list:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">getFavoriteNumber</span>()<span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span>:<span class="tm-typ"> number</span> </span>{
    <span class="tm-kw">return</span> <span class="tm-num">26</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20getFavoriteNumber()%3A%20number%20%7B%0A%20%20%20%20return%2026%3B%0A%7D">Try</a></pre></p>
<p>Much like variable type annotations, you usually don't need a return type annotation because TypeScript will infer the function's return type based on its <code>return</code> statements.
The type annotation in the above example doesn't change anything.
Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.</p>
<h3 id="function-expressions"><a href="#function-expressions">Function Expressions</h3></a>
<p>Function expressions are a little bit different from function declarations.
When a function expression appears in a place where TypeScript can determine how it's going to be called, the parameters of that function are automatically given types.</p>
<p>Here's an example:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// No type annotations here, but TypeScript can spot the bug</span>
<span class="tm-kw">const</span> <span class="tm-vr">names</span> = [<span class="tm-str">"Alice"</span>, <span class="tm-str">"Bob"</span>, <span class="tm-str">"Eve"</span>];
<span class="tm-vr">names</span>.<span class="tm-mth">forEach</span>(<span class="tm-kw">function</span> (<span class="tm-vr">s</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2551-147-11"><span class="error-highlight"></span><span class="tm-mth">toUppercase</span><span id="errLabel-2551-147-11" role="tooltip" class="error-tooltip">Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</span></span>());
});<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20No%20type%20annotations%20here%2C%20but%20TypeScript%20can%20spot%20the%20bug%0Aconst%20names%20%3D%20%5B%22Alice%22%2C%20%22Bob%22%2C%20%22Eve%22%5D%3B%0Anames.forEach(function%20(s)%20%7B%0A%20%20%20%20console.log(s.toUppercase())%3B%0A%7D)%3B">Try</a></pre></p>
<p>Even though the parameter <code>s</code> didn't have a type annotation, TypeScript used the types of the <code>forEach</code> function, along with the inferred type of the array, to determine the type <code>s</code> will have.</p>
<p>This process is called <em>contextual typing</em> because the <em>context</em> that the function occurred in informed what type it should have.
Similar to the inference rules, you don't need to explicitly learn how this happens, but understanding that it <em>does</em> happen can help you notice when type annotations aren't needed.
Later, we'll see more examples of how the context that a value occurs in can affect its type.</p>
<h2 id="object-types"><a href="#object-types">Object Types</h2></a>
<p>Apart from primitives, the most common sort of type you'll encounter is an <em>object type</em>.
This refers to any JavaScript value with properties, which is almost all of them!
To define an object type, we simply list its properties and their types.</p>
<p>For example, here's a function that takes a point-like object:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// The parameter's type annotation is an object type</span>
<span class="tm-kw">function</span> <span class="tm-mth">printCoord</span>(<span class="tm-vr">pt</span>: <span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span>{ <span class="tm-vr">x</span>: <span class="tm-typ">number</span>, <span class="tm-vr">y</span>: <span class="tm-typ">number</span> }</span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's x value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">x</span>);
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's y value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">y</span>);
}
<span class="tm-mth">printCoord</span>({ <span class="tm-vr">x:</span> <span class="tm-num">3</span>, <span class="tm-vr">y:</span> <span class="tm-num">7</span> });<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20The%20parameter's%20type%20annotation%20is%20an%20object%20type%0Afunction%20printCoord(pt%3A%20%7B%20x%3A%20number%2C%20y%3A%20number%20%7D)%20%7B%0A%20%20console.log(%22The%20coordinate's%20x%20value%20is%20%22%20%2B%20pt.x)%3B%0A%20%20console.log(%22The%20coordinate's%20y%20value%20is%20%22%20%2B%20pt.y)%3B%0A%7D%0AprintCoord(%7B%20x%3A%203%2C%20y%3A%207%20%7D)%3B">Try</a></pre></p>
<p>Here, we annotated the parameter with a type with two properties - <code>x</code> and <code>y</code> - which are both of type <code>number</code>.
You can use <code>,</code> or <code>;</code> to separate the properties, and the last separator is optional either way.</p>
<p>The type part of each property is also optional.
If you don't specify a type, it will be assumed to be <code>any</code>.</p>
<h3 id="optional-properties"><a href="#optional-properties">Optional Properties</h3></a>
<p>Object types can also specify that some or all of their properties are <em>optional</em>.
To do this, add a <code>?</code> after the property name:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printName</span>(<span class="tm-vr">obj</span>: { <span class="tm-vr">first</span>: <span class="tm-typ">string</span>, <span class="tm-vr">last</span>?: <span class="tm-typ">string</span>}) {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-cmt">// Both OK</span>
<span class="tm-mth">printName</span>({ <span class="tm-vr">first:</span> <span class="tm-str">"Bob"</span> });
<span class="tm-mth">printName</span>({ <span class="tm-vr">first:</span> <span class="tm-str">"Alice"</span>, <span class="tm-vr">last:</span> <span class="tm-str">"Alisson"</span> });<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printName(obj%3A%20%7B%20first%3A%20string%2C%20last%3F%3A%20string%7D)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%2F%2F%20Both%20OK%0AprintName(%7B%20first%3A%20%22Bob%22%20%7D)%3B%0AprintName(%7B%20first%3A%20%22Alice%22%2C%20last%3A%20%22Alisson%22%20%7D)%3B">Try</a></pre></p>
<p>In JavaScript, if you access a property that doesn't exist, you'll get the value <code>undefined</code> rather than a runtime error.
Because of this, when you <em>read</em> from an optional property, you'll have to check for <code>undefined</code> before using it.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printName</span>(<span class="tm-vr">obj</span>: { <span class="tm-vr">first</span>: <span class="tm-typ">string</span>, <span class="tm-vr">last</span>?: <span class="tm-typ">string</span>}) {
  <span class="tm-cmt">// Error - might crash if 'obj.last' wasn't provided!</span>
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2532-129-8"><span class="error-highlight"></span><span class="tm-vr">obj</span>.<span class="tm-vr">last</span><span id="errLabel-2532-129-8" role="tooltip" class="error-tooltip">Object is possibly 'undefined'.</span></span>.<span class="tm-mth">toUpperCase</span>());
  <span class="tm-kw">if</span> (<span class="tm-vr">obj</span>.<span class="tm-vr">last</span> !== <span class="tm-kw">undefined</span>) {
    <span class="tm-cmt">// OK</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">obj</span>.<span class="tm-vr">last</span>.<span class="tm-mth">toUpperCase</span>());
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'undefined'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printName(obj%3A%20%7B%20first%3A%20string%2C%20last%3F%3A%20string%7D)%20%7B%0A%20%20%2F%2F%20Error%20-%20might%20crash%20if%20'obj.last'%20wasn't%20provided!%0A%20%20console.log(obj.last.toUpperCase())%3B%0A%20%20if%20(obj.last%20!%3D%3D%20undefined)%20%7B%0A%20%20%20%20%2F%2F%20OK%0A%20%20%20%20console.log(obj.last.toUpperCase())%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="union-types"><a href="#union-types">Union Types</h2></a>
<p>TypeScript's type system allows you to build new types out of existing ones using a large variety of operators.
Now that we know how to write a few types, it's time to start <em>combining</em> them in interesting ways.</p>
<h3 id="defining-a-union-type"><a href="#defining-a-union-type">Defining a Union Type</h3></a>
<p>The first way to combine types you might see is a <em>union</em> type.
A union type is type formed from two or more other types, representing values that may be <em>any one</em> of those types.
We refer to each of these types as the union's <em>members</em>.</p>
<p>Let's write a function that can operate on strings or numbers:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printId</span>(<span class="tm-vr">id</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Your ID is: "</span> + <span class="tm-vr">id</span>);
}
<span class="tm-cmt">// OK</span>
<span class="tm-mth">printId</span>(<span class="tm-num">101</span>);
<span class="tm-cmt">// OK</span>
<span class="tm-mth">printId</span>(<span class="tm-str">"202"</span>);
<span class="tm-cmt">// Error</span>
<span class="tm-mth">printId</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-137-6"><span class="error-highlight"></span>[<span class="tm-num">1</span>, <span class="tm-num">2</span>]<span id="errLabel-2345-137-6" role="tooltip" class="error-tooltip">Argument of type 'number[]' is not assignable to parameter of type 'string | number'.
  Type 'number[]' is not assignable to type 'string'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'number[]' is not assignable to parameter of type 'string | number'.</div><div class="error-line"><div class="indent"></div>Type 'number[]' is not assignable to type 'string'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20console.log(%22Your%20ID%20is%3A%20%22%20%2B%20id)%3B%0A%7D%0A%2F%2F%20OK%0AprintId(101)%3B%0A%2F%2F%20OK%0AprintId(%22202%22)%3B%0A%2F%2F%20Error%0AprintId(%5B1%2C%202%5D)%3B">Try</a></pre></p>
<h3 id="working-with-union-types"><a href="#working-with-union-types">Working with Union Types</h3></a>
<p>It's easy to <em>provide</em> a value matching a union type - simply provide a type matching any of the union's members.
If you <em>have</em> a value of a union type, how do you work with it?</p>
<p>TypeScript will only allow you to do things with the union if that thing is valid for <em>every</em> member of the union.
For example, if you have the union <code>string | number</code>, you can't use methods that are only available on <code>string</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printId</span>(<span class="tm-vr">id</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">id</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2339-57-11"><span class="error-highlight"></span><span class="tm-mth">toUpperCase</span><span id="errLabel-2339-57-11" role="tooltip" class="error-tooltip">Property 'toUpperCase' does not exist on type 'string | number'.
  Property 'toUpperCase' does not exist on type 'number'.</span></span>());
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'toUpperCase' does not exist on type 'string | number'.</div><div class="error-line"><div class="indent"></div>Property 'toUpperCase' does not exist on type 'number'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20console.log(id.toUpperCase())%3B%0A%7D">Try</a></pre></p>
<p>The solution is to <em>narrow</em> the union with code, the same as you would in JavaScript without type annotations.
<em>Narrowing</em> occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.</p>
<p>For example, TypeScript knows that only a <code>string</code> value will have a <code>typeof</code> value <code>"string"</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printId</span>(<span class="tm-vr">id</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>) {
  <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">id</span> === <span class="tm-str">"string"</span>) {
    <span class="tm-cmt">// In this branch, id is of type 'string'</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">id</span>.<span class="tm-mth">toUpperCase</span>());
  } <span class="tm-kw">else</span> {
    <span class="tm-cmt">// Here, id is of type 'number'</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">id</span>);
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printId(id%3A%20number%20%7C%20string)%20%7B%0A%20%20if%20(typeof%20id%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%2F%2F%20In%20this%20branch%2C%20id%20is%20of%20type%20'string'%0A%20%20%20%20console.log(id.toUpperCase())%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20Here%2C%20id%20is%20of%20type%20'number'%0A%20%20%20%20console.log(id)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Another example is to use a function like <code>Array.isArray</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">welcomePeople</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span>[] | <span class="tm-typ">string</span>) {
  <span class="tm-kw">if</span> (<span class="tm-typ">Array</span>.<span class="tm-mth">isArray</span>(<span class="tm-vr">x</span>)) {
    <span class="tm-cmt">// Here: 'x' is 'string[]'</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-vr">x</span>.<span class="tm-mth">join</span>(<span class="tm-str">" and "</span>));
  } <span class="tm-kw">else</span> {
    <span class="tm-cmt">// Here: 'x' is 'string'</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Welcome lone traveler "</span> + <span class="tm-vr">x</span>);
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20welcomePeople(x%3A%20string%5B%5D%20%7C%20string)%20%7B%0A%20%20if%20(Array.isArray(x))%20%7B%0A%20%20%20%20%2F%2F%20Here%3A%20'x'%20is%20'string%5B%5D'%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20x.join(%22%20and%20%22))%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20Here%3A%20'x'%20is%20'string'%0A%20%20%20%20console.log(%22Welcome%20lone%20traveler%20%22%20%2B%20x)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Notice that in the <code>else</code> branch, we don't need to do anything special - if <code>x</code> wasn't a <code>string[]</code>, then it must have been a <code>string</code>.</p>
<p>Sometimes you'll have a union where all the members have something in common.
For example, both arrays and strings have a <code>slice</code> method.
If every member in a union has a property in common, you can use that property without narrowing:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Return type is inferred as number[] | string</span>
<span class="tm-kw">function</span> <span class="tm-mth">getFirstThree</span>(<span class="tm-vr">x</span>: <span class="tm-typ">number</span>[] | <span class="tm-typ">string</span>) {
  <span class="tm-kw">return</span> <span class="tm-vr">x</span>.<span class="tm-mth">slice</span>(<span class="tm-num">0</span>, <span class="tm-num">3</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Return%20type%20is%20inferred%20as%20number%5B%5D%20%7C%20string%0Afunction%20getFirstThree(x%3A%20number%5B%5D%20%7C%20string)%20%7B%0A%20%20return%20x.slice(0%2C%203)%3B%0A%7D">Try</a></pre></p>
<blockquote>
  <p>It might be confusing that a <em>union</em> of types appears to have the <em>intersection</em> of those types' properties.
  This is not an accident - the name <em>union</em> comes from type theory.
  The <em>union</em> <code>number | string</code> is composed by taking the union <em>of the values</em> from each type.
  Notice that given two sets with corresponding facts about each set, only the <em>intersection</em> of those facts applies to the <em>union</em> of the sets themselves.
  For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearings hats, after combining those rooms, the only thing we know about <em>every</em> person is that they must be wearing a hat.</p>
</blockquote>
<h2 id="type-aliases"><a href="#type-aliases">Type Aliases</h2></a>
<p>We've been using object types and union types by writing them directly in type annotations.
This is convenient, but it's common to want to use the same type more than once and refer to it by a single name.</p>
<p>A <em>type alias</em> is exactly that - a <em>name</em> for any <em>type</em>.
The syntax for a type alias is:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Point</span></span> = {
  <span class="tm-vr">x</span>: <span class="tm-typ">number</span>,
  <span class="tm-vr">y</span>: <span class="tm-typ">number</span>
};

<span class="tm-cmt">// Exactly the same as the earlier example</span>
<span class="tm-kw">function</span> <span class="tm-mth">printCoord</span>(<span class="tm-vr">pt</span>: <span class="tm-typ"><span class="typeAliasName">Point</span></span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's x value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">x</span>);
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's y value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">y</span>);
}

<span class="tm-mth">printCoord</span>({ <span class="tm-vr">x:</span> <span class="tm-num">100</span>, <span class="tm-vr">y:</span> <span class="tm-num">100</span> });<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Point%20%3D%20%7B%0A%20%20x%3A%20number%2C%0A%20%20y%3A%20number%0A%7D%3B%0A%0A%2F%2F%20Exactly%20the%20same%20as%20the%20earlier%20example%0Afunction%20printCoord(pt%3A%20Point)%20%7B%0A%20%20console.log(%22The%20coordinate's%20x%20value%20is%20%22%20%2B%20pt.x)%3B%0A%20%20console.log(%22The%20coordinate's%20y%20value%20is%20%22%20%2B%20pt.y)%3B%0A%7D%0A%0AprintCoord(%7B%20x%3A%20100%2C%20y%3A%20100%20%7D)%3B">Try</a></pre></p>
<p>You can actually use a type alias to give a name to any type at all, not just an object type.
For example, a type alias can name a union type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">ID</span></span> = <span class="tm-typ">number</span> | <span class="tm-typ">string</span>;</pre></p>
<p>Note that aliases are <em>only</em> aliases - you cannot use type aliases to create different/distinct "versions" of the same type.
When you use the alias, it's exactly as if you had written the aliased type.
In other words, this code might <em>look</em> illegal, but is OK according to TypeScript because both types are aliases for the same type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Age</span></span> = <span class="tm-typ">number</span>;
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Weight</span></span> = <span class="tm-typ">number</span>;

<span class="tm-kw">const</span> <span class="tm-vr">myAge</span>: <span class="tm-typ"><span class="typeAliasName">Age</span></span> = <span class="tm-num">73</span>;
<span class="tm-cmt">// *not* an error</span>
<span class="tm-kw">const</span> <span class="tm-vr">myWeight</span>: <span class="tm-typ"><span class="typeAliasName">Weight</span></span> = <span class="tm-vr">myAge</span>;<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Age%20%3D%20number%3B%0Atype%20Weight%20%3D%20number%3B%0A%0Aconst%20myAge%3A%20Age%20%3D%2073%3B%0A%2F%2F%20*not*%20an%20error%0Aconst%20myWeight%3A%20Weight%20%3D%20myAge%3B">Try</a></pre></p>
<h2 id="interfaces"><a href="#interfaces">Interfaces</h2></a>
<p>An <em>interface declaration</em> is another way to name an object type:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Point</span></span> {
  <span class="tm-vr">x</span>: <span class="tm-typ">number</span>;
  <span class="tm-vr">y</span>: <span class="tm-typ">number</span>;
}

<span class="tm-kw">function</span> <span class="tm-mth">printCoord</span>(<span class="tm-vr">pt</span>: <span class="tm-typ"><span class="interfaceName">Point</span></span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's x value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">x</span>);
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"The coordinate's y value is "</span> + <span class="tm-vr">pt</span>.<span class="tm-vr">y</span>);
}

<span class="tm-mth">printCoord</span>({ <span class="tm-vr">x:</span> <span class="tm-num">100</span>, <span class="tm-vr">y:</span> <span class="tm-num">100</span> });<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Point%20%7B%0A%20%20x%3A%20number%3B%0A%20%20y%3A%20number%3B%0A%7D%0A%0Afunction%20printCoord(pt%3A%20Point)%20%7B%0A%20%20console.log(%22The%20coordinate's%20x%20value%20is%20%22%20%2B%20pt.x)%3B%0A%20%20console.log(%22The%20coordinate's%20y%20value%20is%20%22%20%2B%20pt.y)%3B%0A%7D%0A%0AprintCoord(%7B%20x%3A%20100%2C%20y%3A%20100%20%7D)%3B">Try</a></pre></p>
<p>Just like when we used a type alias above, the example works just as if we had used an anonymous object type.
TypeScript is only concerned with the <em>structure</em> of the value we passed to <code>printCoord</code> - it only cares that it has the expected properties.
Being concerned only with the structure and capabilities of types is why we call TypeScript a <em>structurally typed</em> type system.</p>
<h3 id="interface-vs-alias"><a href="#interface-vs-alias">Differences Between Type Aliases and Interfaces</h3></a>
<p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely.
Here are the most relevant differences between the two that you should be aware of.
You'll learn more about these concepts in later chapters, so don't worry if you don't understand all of these right away.</p>
<ul>
<li>Interfaces may be <code>extend</code>ed, but not type aliases. We'll discuss this later, but it means that interfaces can provide more guarantees when creating new types out of other types.</li>
<li>Type aliases may not participate in declaration merging, but interfaces can.</li>
<li>Interfaces may only be used to declare object types.</li>
<li>Interface names will <em>always</em> appear in their original form in error messages, but <em>only</em> when they are used by name.</li>
<li>Type alias names <em>may</em> appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable).</li>
</ul>
<p>For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration.</p>
<h2 id="type-assertions"><a href="#type-assertions">Type Assertions</h2></a>
<p>Sometimes you will have information about the type of a value that TypeScript can't know about.</p>
<p>For example, if you're using <code>document.getElementById</code>, TypeScript only knows that this will return <em>some</em> kind of <code>HTMLElement</code>, but you might know that your page will always have an <code>HTMLCanvasElement</code> with a given ID.</p>
<p>In this situation, you can use a <em>type assertion</em> to specify a more specific type:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">myCanvas</span> = <span class="tm-vr">document</span>.<span class="tm-mth">getElementById</span>(<span class="tm-str">"main_canvas"</span>) <span class="tm-kw">as</span> <span class="tm-typ"><span class="interfaceName">HTMLCanvasElement</span></span>;</pre></p>
<p>Like a type annotation, type assertions are removed by the compiler and won't affect the runtime behavior of your code.</p>
<p>You can also use the angle-bracket syntax (except if the code is in a <code>.tsx</code> file), which is equivalent:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">myCanvas</span> = <<span class="tm-typ"><span class="interfaceName">HTMLCanvasElement</span></span>><span class="tm-vr">document</span>.<span class="tm-mth">getElementById</span>(<span class="tm-str">"main_canvas"</span>);</pre></p>
<blockquote>
  <p>Reminder: Because they are removed at compile-time, there is no runtime checking associated with a type assertion.
  There won't be an exception or <code>null</code> generated if the type assertion is wrong.</p>
</blockquote>
<p>TypeScript only allows type assertions which convert to a <em>more specific</em> or <em>less specific</em> version of a type.
This rule prevents "impossible" coercions like:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">x</span> = <span class="error" tabindex="0" aria-describedby="errLabel-2352-10-17"><span class="error-highlight"></span><span class="tm-str">"hello"</span> <span class="tm-kw">as</span> <span class="tm-typ">number</span><span id="errLabel-2352-10-17" role="tooltip" class="error-tooltip">Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</div></div></pre></p>
<p>Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid.
If this happens, you can use two assertions, first to <code>any</code> (or <code>unknown</code>, which we'll introduce later), then to the desired type:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">a</span> = <span class="tm-vr">expr</span> <span class="tm-kw">as</span> <span class="tm-typ">any</span> <span class="tm-typ">as</span> <span class="tm-typ"><span class="typeAliasName">T</span></span>;</pre></p>
<h2 id="literal-types"><a href="#literal-types">Literal Types</h2></a>
<p>In addition to the general types <code>string</code> and <code>number</code>, we can refer to <em>specific</em> strings and numbers in type positions.</p>
<p>By themselves, literal types aren't very valuable:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">x</span>: <span class="tm-str">"hello"</span> = <span class="tm-str">"hello"</span>;
<span class="tm-cmt">// OK</span>
<span class="tm-vr">x</span> = <span class="tm-str">"hello"</span>;
<span class="tm-cmt">// OK</span>
<span class="tm-vr">x</span> = <span class="tm-str">"hello"</span>;
<span class="tm-cmt">// ...</span>
<span class="error" tabindex="0" aria-describedby="errLabel-2322-71-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2322-71-1" role="tooltip" class="error-tooltip">Type '"howdy"' is not assignable to type '"hello"'.</span></span> = <span class="tm-str">"howdy"</span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Type '"howdy"' is not assignable to type '"hello"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20x%3A%20%22hello%22%20%3D%20%22hello%22%3B%0A%2F%2F%20OK%0Ax%20%3D%20%22hello%22%3B%0A%2F%2F%20OK%0Ax%20%3D%20%22hello%22%3B%0A%2F%2F%20...%0Ax%20%3D%20%22howdy%22%3B">Try</a></pre></p>
<p>It's not much use to have a variable that can only have one value!</p>
<p>But by <em>combining</em> literals into unions, you can express a much more useful thing - for example, functions that only accept a certain set of known values:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printText</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>, <span class="tm-vr">alignment</span>: <span class="tm-str">"left"</span> | <span class="tm-str">"right"</span> | <span class="tm-str">"center"</span>) {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-mth">printText</span>(<span class="tm-str">"Hello, world"</span>, <span class="tm-str">"left"</span>);
<span class="tm-mth">printText</span>(<span class="tm-str">"G'day, mate"</span>, <span class="error" tabindex="0" aria-describedby="errLabel-2345-143-8"><span class="error-highlight"></span><span class="tm-str">"centre"</span><span id="errLabel-2345-143-8" role="tooltip" class="error-tooltip">Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printText(s%3A%20string%2C%20alignment%3A%20%22left%22%20%7C%20%22right%22%20%7C%20%22center%22)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0AprintText(%22Hello%2C%20world%22%2C%20%22left%22)%3B%0AprintText(%22G'day%2C%20mate%22%2C%20%22centre%22)%3B">Try</a></pre></p>
<p>Numeric literal types work the same way:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">compare</span>(<span class="tm-vr">a</span>: <span class="tm-typ">string</span>, <span class="tm-vr">b</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> -</span><span class="tm-num">1</span><span class="tm-typ"> </span>|<span class="tm-typ"> </span><span class="tm-num">0</span><span class="tm-typ"> </span>|<span class="tm-typ"> </span><span class="tm-num">1</span><span class="tm-typ"> </span>{
  <span class="tm-kw">return</span> <span class="tm-vr">a</span> === <span class="tm-vr">b</span> ? <span class="tm-num">0</span> : <span class="tm-vr">a</span> > <span class="tm-vr">b</span> ? <span class="tm-num">1</span> : -<span class="tm-num">1</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20compare(a%3A%20string%2C%20b%3A%20string)%3A%20-1%20%7C%200%20%7C%201%20%7B%0A%20%20return%20a%20%3D%3D%3D%20b%20%3F%200%20%3A%20a%20%3E%20b%20%3F%201%20%3A%20-1%3B%0A%7D">Try</a></pre></p>
<p>Of course, you can combine these with non-literal types:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Options</span></span> {
  <span class="tm-vr">width</span>: <span class="tm-typ">number</span>;
}
<span class="tm-kw">function</span> <span class="tm-mth">configure</span>(<span class="tm-vr">x</span>: <span class="tm-typ"><span class="interfaceName">Options</span></span> | <span class="tm-str">"auto"</span>) {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-mth">configure</span>({ <span class="tm-vr">width:</span> <span class="tm-num">100</span> });
<span class="tm-mth">configure</span>(<span class="tm-str">"auto"</span>);
<span class="tm-mth">configure</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-148-11"><span class="error-highlight"></span><span class="tm-str">"automatic"</span><span id="errLabel-2345-148-11" role="tooltip" class="error-tooltip">Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Options%20%7B%0A%20%20width%3A%20number%3B%0A%7D%0Afunction%20configure(x%3A%20Options%20%7C%20%22auto%22)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0Aconfigure(%7B%20width%3A%20100%20%7D)%3B%0Aconfigure(%22auto%22)%3B%0Aconfigure(%22automatic%22)%3B">Try</a></pre></p>
<p>There's one more kind of literal type: boolean literals.
There are only two boolean literal types, and as you might guess, they are the types <code>true</code> and <code>false</code>.
The type <code>boolean</code> itself is actually just an alias for the union <code>true | false</code>.</p>
<h3 id="literal-inference"><a href="#literal-inference">Literal Inference</h3></a>
<p>When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later.
For example, if you wrote code like this:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">obj</span> = { <span class="tm-vr">counter:</span> <span class="tm-num">0</span> };
<span class="tm-kw">if</span> (<span class="tm-vr">someCondition</span>) {
  <span class="tm-vr">obj</span>.<span class="tm-vr">counter</span> = <span class="tm-num">1</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20const%20someCondition%3A%20boolean%3B%0A%2F%2Fcut%0Aconst%20obj%20%3D%20%7B%20counter%3A%200%20%7D%3B%0Aif%20(someCondition)%20%7B%0A%20%20obj.counter%20%3D%201%3B%0A%7D">Try</a></pre></p>
<p>TypeScript doesn't assume the assignment of <code>1</code> to a field that previously had <code>0</code> to be an error.
Another way of saying this is that <code>obj.counter</code> must have the type <code>number</code>, not <code>0</code>, because types are used to determine both <em>reading</em> and <em>writing</em> behavior.</p>
<p>The same applies to strings:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">req</span> = { <span class="tm-vr">url:</span> <span class="tm-str">"https://example.com"</span>, <span class="tm-vr">method:</span> <span class="tm-str">"GET"</span> };
<span class="tm-mth">handleRequest</span>(<span class="tm-vr">req</span>.<span class="tm-vr">url</span>, <span class="error" tabindex="0" aria-describedby="errLabel-2345-163-10"><span class="error-highlight"></span><span class="tm-vr">req</span>.<span class="tm-vr">method</span><span id="errLabel-2345-163-10" role="tooltip" class="error-tooltip">Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.</div></div></pre></p>
<!-- TODO: Use and explain const contexts -->
<p>Because it'd be legal to assign a string like <code>"GUESS"</code> TO <code>req.method</code>, TypeScript considers this code to have an error.
You can change this inference by adding a type assertion in either location:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">req</span> = { <span class="tm-vr">url:</span> <span class="tm-str">"https://example.com"</span>, <span class="tm-vr">method:</span> <span class="tm-str">"GET"</span> <span class="tm-kw">as</span> <span class="tm-str">"GET"</span> };
<span class="tm-cmt">/* or */</span>
<span class="tm-mth">handleRequest</span>(<span class="tm-vr">req</span>.<span class="tm-vr">url</span>, <span class="tm-vr">req</span>.<span class="tm-vr">method</span> <span class="tm-kw">as</span> <span class="tm-str">"GET"</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20handleRequest(url%3A%20string%2C%20method%3A%20%22GET%22%20%7C%20%22POST%22)%3A%20void%3B%0A%2F%2Fcut%0Aconst%20req%20%3D%20%7B%20url%3A%20%22https%3A%2F%2Fexample.com%22%2C%20method%3A%20%22GET%22%20as%20%22GET%22%20%7D%3B%0A%2F*%20or%20*%2F%0AhandleRequest(req.url%2C%20req.method%20as%20%22GET%22)%3B">Try</a></pre></p>
<p>The first change means "I intend for <code>req.method</code> to always have the <em>literal type</em> <code>"GET"</code>", preventing the possible assignment of <code>"GUESS"</code> to that field.
The second change means "I know for other reasons that <code>req.method</code> has the value <code>"GET"</code>".</p>
<h2 id="null-and-undefined"><a href="#null-and-undefined"><code>null</code> and <code>undefined</code></h2></a>
<p>JavaScript has two primitive values, <code>null</code> and <code>undefined</code>, both of which are used to signal absent or uninitialized values.</p>
<p>TypeScript has two corresponding <em>types</em> by the same names. How these types behave depends on whether you have the <code>strictNullChecks</code> option on.</p>
<h3 id="strictnullchecks-off"><a href="#strictnullchecks-off"><code>strictNullChecks</code> off</h3></a>
<p>With <code>strictNullChecks</code> <em>off</em>, values that might be <code>null</code> or <code>undefined</code> can still be accessed normally, and the values <code>null</code> and <code>undefined</code> can be assigned to a property of any type.
This is similar to how languages without null checks (e.g. C#, Java) behave.
The lack of checking for these values tends to be a major source of bugs; we always recommend people turn <code>strictNullChecks</code> on if it's practical to do so in their codebase.</p>
<h3 id="strictnullchecks-on"><a href="#strictnullchecks-on"><code>strictNullChecks</code> on</h3></a>
<p>With <code>strictNullChecks</code> <em>on</em>, when a value is <code>null</code> or <code>undefined</code>, you will need to test for those values before using methods or properties on that value.
Just like checking for <code>undefined</code> before using an optional property, we can use <em>narrowing</em> to check for values that might be <code>null</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">doSomething</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span> | <span class="tm-typ">null</span>) {
  <span class="tm-kw">if</span> (<span class="tm-vr">x</span> === <span class="tm-kw">null</span>) {
    <span class="tm-cmt">// do nothing</span>
  } <span class="tm-kw">else</span> {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-vr">x</span>.<span class="tm-mth">toUpperCase</span>());
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20doSomething(x%3A%20string%20%7C%20null)%20%7B%0A%20%20if%20(x%20%3D%3D%3D%20null)%20%7B%0A%20%20%20%20%2F%2F%20do%20nothing%0A%20%20%7D%20else%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20x.toUpperCase())%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h3 id="non-null-operator"><a href="#non-null-operator">Non-null Assertion Operator (Postfix <code>!</code>)</h3></a>
<p>TypeScript also has a special syntax for removing <code>null</code> and <code>undefined</code> from a type without doing any explicit checking.
Writing <code>!</code> after any expression is effectively a type assertion that the value isn't <code>null</code> or <code>undefined</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">liveDangerously</span>(<span class="tm-vr">x</span>?: <span class="tm-typ">number</span> | <span class="tm-typ">null</span>) {
  <span class="tm-cmt">// No error</span>
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>!.<span class="tm-mth">toFixed</span>());
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20liveDangerously(x%3F%3A%20number%20%7C%20null)%20%7B%0A%20%20%2F%2F%20No%20error%0A%20%20console.log(x!.toFixed())%3B%0A%7D">Try</a></pre></p>
<p>Just like other type assertions, this doesn't change the runtime behavior of your code, so it's important to only use <code>!</code> when you know that the value <em>can't</em> be <code>null</code> or <code>undefined</code>.</p><hr><h1 id="type-declarations"><a href="#type-declarations">Type Declarations</h1></a>
<p>Throughout the sections you've read so far, we've been demonstrating basic TypeScript concepts using the built-in functions present in all JavaScript runtimes.
However, almost all JavaScript today includes many libraries to accomplish common tasks.
Having types for the parts of your application that <em>aren't</em> your code will greatly improve your TypeScript experience.
Where do these types come from?</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#what-do-type-declarations-look-like?">What Do Type Declarations Look Like?</a></li><li><a href="#.d.ts-files"><code>.d.ts</code> files</a></li><li><a href="#built-in-type-definitions">Built-in Type Definitions</a></li><ul><li><a href="#target-setting"><code>target</code> setting</a></li><li><a href="#lib-setting"><code>lib</code> setting</a></li></ul><li><a href="#external-definitions">External Definitions</a></li><ul><li><a href="#bundled-types">Bundled Types</a></li><li><a href="#definitelytyped--@types">DefinitelyTyped / <code>@types</code></a></li><li><a href="#your-own-definitions">Your Own Definitions</a></li></ul></ul></ul></div>
<h2 id="what-do-type-declarations-look-like"><a href="#what-do-type-declarations-look-like">What Do Type Declarations Look Like?</h2></a>
<p>Let's say you write some code like this:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">k</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">max</span>(<span class="tm-num">5</span>, <span class="tm-num">6</span>);
<span class="tm-kw">const</span> <span class="tm-vr">j</span> = <span class="tm-typ">Math</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2339-41-3"><span class="error-highlight"></span><span class="tm-mth">mix</span><span id="errLabel-2339-41-3" role="tooltip" class="error-tooltip">Property 'mix' does not exist on type 'Math'.</span></span>(<span class="tm-num">7</span>, <span class="tm-num">8</span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'mix' does not exist on type 'Math'.</div></div></pre></p>
<p>How did TypeScript know that <code>max</code> was present but not <code>mix</code>, even though <code>Math</code>'s implementation wasn't part of your code?</p>
<p>The answer is that there are <em>declaration files</em> describing these built-in objects.
A declaration file provides a way to <em>declare</em> the existence of some types or values without actually providing implementations for those values.</p>
<h2 id="dts-files"><a href="#dts-files"><code>.d.ts</code> files</h2></a>
<p>TypeScript has two main kinds of files.
<code>.ts</code> files are <em>implementation</em> files that contain types and executable code.
These are the files that produce <code>.js</code> outputs, and are where you'd normally write your code.</p>
<p><code>.d.ts</code> files are <em>declaration</em> files that contain <em>only</em> type information.
These files don't produce <code>.js</code> outputs; they are only used for typechecking.
We'll learn more about how to write our own declaration files later.</p>
<h2 id="built-in-type-definitions"><a href="#built-in-type-definitions">Built-in Type Definitions</h2></a>
<p>TypeScript includes declaration files for all of the standardized built-in APIs available in JavaScript runtimes.
This includes things like methods and properties of built-in types like <code>string</code> or <code>function</code>, top-level names like <code>Math</code> and <code>Object</code>, and their associated types.
By default, TypeScript also includes types for things available when running inside the browser, such as <code>window</code> and <code>document</code>; these are collectively referred to as the DOM APIs.</p>
<p>TypeScript names these declaration files with the pattern <code>lib.[something].d.ts</code>.
If you navigate into a file with that name, you can know that you're dealing with some built-in part of the platform, not user code.</p>
<h3 id="target-setting"><a href="#target-setting"><code>target</code> setting</h3></a>
<p>The methods, properties, and functions available to you actually vary based on the <em>version</em> of JavaScript your code is running on.
For example, the <code>startsWith</code> method of strings is available only starting with the version of JavaScript referred as <em>ECMAScript 6</em>.</p>
<p>Being aware of what version of JavaScript your code ultimately runs on is important because you don't want to use APIs that are from a newer version than the platform you deploy to.
This is one function of the <code>target</code> compiler setting.</p>
<p>TypeScript helps with this problem by varying which <code>lib</code> files are included by default based on your <code>target</code> setting.
For example, if <code>target</code> is <code>ES5</code>, you will see an error if trying to use the <code>startsWith</code> method, because that method is only available in <code>ES6</code> or later.</p>
<h3 id="lib-setting"><a href="#lib-setting"><code>lib</code> setting</h3></a>
<p>The <code>lib</code> setting allows more fine-grained control of which built-in declaration files are considered available in your program.
See the documentation page on lib for more information.</p>
<h2 id="external-definitions"><a href="#external-definitions">External Definitions</h2></a>
<p>For non-built-in APIs, there are a variety of ways you can get declaration files.
How you do this depends on exactly which library you're getting types for.</p>
<h3 id="bundled-types"><a href="#bundled-types">Bundled Types</h3></a>
<p>If a library you're using is published as an npm package, it may include type declaration files as part of its distribution already.
You can read the project's documentation to find out, or simply try importing the package and see if TypeScript is able to automatically resolve the types for you.</p>
<p>If you're a package author considering bundling type definitions with your package, you can read our guide on bundling type definitions.</p>
<h3 id="definitelytyped--types"><a href="#definitelytyped--types">DefinitelyTyped / <code>@types</code></h3></a>
<p>The <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped repository</a> is a centralized repo storing declaration files for thousands of libraries.
The vast majority of commonly-used libraries have declaration files available on DefinitelyTyped.</p>
<p>Definitions on DefinitelyTyped are also automatically published to npm under the <code>@types</code> scope.
The name of the types package is always the same as the name of the underlying package itself.
For example, if you installed the <code>react</code> npm package, you can install its corresponding types by running</p>
<pre><code class="sh language-sh">npm install --save-dev @types/react
</code></pre>
<p>TypeScript automatically finds type definitions under <code>node_modules/@types</code>, so there's no other step needed to get these types available in your program.</p>
<h3 id="your-own-definitions"><a href="#your-own-definitions">Your Own Definitions</h3></a>
<p>In the uncommon event that a library didn't bundle its own types and didn't have a definition on DefinitelyTyped, you can write a declaration file yourself.
See the appendix Writing Declaration Files for a guide.</p>
<p>If you want to silence warnings about a particular module without writing a declaration file, you can also quick declare the module as type <code>any</code> by putting an empty declaration for it in a <code>.d.ts</code> file in your project.
For example, if you wanted to use a module named <code>some-untyped-module</code> without having definitions for it, you would write:</p>
<p><pre class="typescript-code"><span class="tm-kw">declare</span> <span class="tm-kw">module</span> <span class="tm-str">"some-untyped-module"</span>;</pre></p><hr><h1 id="narrowing"><a href="#narrowing">Narrowing</h1></a>
<p>Imagine we have a function called <code>padLeft</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">padLeft</span>(<span class="tm-vr">padding</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>, <span class="tm-vr">input</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> string </span>{
    <span class="tm-kw">throw</span> <span class="tm-kw">new</span> <span class="tm-typ">Error</span>(<span class="tm-str">"Not implemented yet!"</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20padLeft(padding%3A%20number%20%7C%20string%2C%20input%3A%20string)%3A%20string%20%7B%0A%20%20%20%20throw%20new%20Error(%22Not%20implemented%20yet!%22)%3B%0A%7D">Try</a></pre></p>
<p>If <code>padding</code> is a <code>number</code>, it will treat that as the number of spaces we want to prepend to <code>input</code>.
If <code>padding</code> is a <code>string</code>, it should just prepend <code>padding</code> to <code>input</code>.
Let's try to implement the logic for when <code>padLeft</code> is passed a <code>number</code> for <code>padding</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">padLeft</span>(<span class="tm-vr">padding</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>, <span class="tm-vr">input</span>: <span class="tm-typ">string</span>) {
    <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Array</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2365-81-11"><span class="error-highlight"></span><span class="tm-vr">padding</span> + <span class="tm-num">1</span><span id="errLabel-2365-81-11" role="tooltip" class="error-tooltip">Operator '+' cannot be applied to types 'string | number' and '1'.</span></span>).<span class="tm-mth">join</span>(<span class="tm-str">" "</span>) + <span class="tm-vr">input</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Operator '+' cannot be applied to types 'string | number' and '1'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20padLeft(padding%3A%20number%20%7C%20string%2C%20input%3A%20string)%20%7B%0A%20%20%20%20return%20new%20Array(padding%20%2B%201).join(%22%20%22)%20%2B%20input%3B%0A%7D">Try</a></pre></p>
<p>Uh-oh, we're getting an error on <code>padding + 1</code>.
TypeScript is warning us that adding a <code>number</code> to a <code>number | string</code> might not give us what we want, and it's right.
In other words, we haven't explicitly checked if <code>padding</code> is a <code>number</code> first, nor are we handling the case where it's a <code>string</code>, so let's do exactly that.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">padLeft</span>(<span class="tm-vr">padding</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>, <span class="tm-vr">input</span>: <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">padding</span> === <span class="tm-str">"number"</span>) {
        <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Array</span>(<span class="tm-vr">padding</span> + <span class="tm-num">1</span>).<span class="tm-mth">join</span>(<span class="tm-str">" "</span>) + <span class="tm-vr">input</span>;
    }
    <span class="tm-kw">return</span> <span class="tm-vr">padding</span> + <span class="tm-vr">input</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20padLeft(padding%3A%20number%20%7C%20string%2C%20input%3A%20string)%20%7B%0A%20%20%20%20if%20(typeof%20padding%20%3D%3D%3D%20%22number%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20new%20Array(padding%20%2B%201).join(%22%20%22)%20%2B%20input%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20padding%20%2B%20input%3B%0A%7D">Try</a></pre></p>
<p>If this mostly looks like uninteresting JavaScript code, that's sort of the point.
Apart from the annotations we put in place, this TypeScript code looks like JavaScript.
The idea is that TypeScript's type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.</p>
<p>While it might not look like much, there's actually a lot going under the covers here.
Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript's runtime control flow constructs like <code>if/else</code>, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.</p>
<p>Within our <code>if</code> check, TypeScript sees <code>typeof padding === "number"</code> and understands that as a special form of code called a <em>type guard</em>.
TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position.
It looks at these special checks (called <em>type guards</em>) and assignments, and the process of refining types to more specific types than declared is called <em>narrowing</em>.
In many editors we can observe these types as they change, and we'll even do so in our examples.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">padLeft</span>(<span class="tm-vr">padding</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>, <span class="tm-vr">input</span>: <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">padding</span> === <span class="tm-str">"number"</span>) {
        <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Array</span>(<span class="tm-vr">padding</span> + <span class="tm-num">1</span>).<span class="tm-mth">join</span>(<span class="tm-str">" "</span>) + <span class="tm-vr">input</span>;
                         <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">padding</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>
    }
    <span class="tm-kw">return</span> <span class="tm-vr">padding</span> + <span class="tm-vr">input</span>;
           <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">padding</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20padLeft(padding%3A%20number%20%7C%20string%2C%20input%3A%20string)%20%7B%0A%20%20%20%20if%20(typeof%20padding%20%3D%3D%3D%20%22number%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20new%20Array(padding%20%2B%201).join(%22%20%22)%20%2B%20input%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20padding%20%2B%20input%3B%0A%7D">Try</a></pre></p>
<p>There are a couple of different constructs TypeScript understands for narrowing.</p>
<h2 id="typeof-type-guards"><a href="#typeof-type-guards"><code>typeof</code> type guards</h2></a>
<p>As we've seen, JavaScript supports a <code>typeof</code> operator which can give very basic information about the type of values we have at runtime.
TypeScript expects this to return a certain set of strings:</p>
<ul>
<li><code>"string"</code></li>
<li><code>"number"</code></li>
<li><code>"bigint"</code></li>
<li><code>"boolean"</code></li>
<li><code>"symbol"</code></li>
<li><code>"undefined"</code></li>
<li><code>"object"</code></li>
<li><code>"function"</code></li>
</ul>
<p>Like we saw with <code>padLeft</code>, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.</p>
<p>In TypeScript, checking against the value returned by <code>typeof</code> is a type guard.
Because TypeScript encodes how <code>typeof</code> operates on different values, it knows about some of its quirks in JavaScript.
For example, notice that in the list above, <code>typeof</code> doesn't return the string <code>null</code>.
Check out the following example:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printAll</span>(<span class="tm-vr">strs</span>: <span class="tm-typ">string</span> | <span class="tm-typ">string</span>[] | <span class="tm-typ">null</span>) {
    <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"object"</span>) {
        <span class="tm-kw">for</span> (<span class="tm-kw">const</span> <span class="tm-vr">s</span> <span class="tm-kw">of</span> <span class="error" tabindex="0" aria-describedby="errLabel-2531-112-4"><span class="error-highlight"></span><span class="tm-vr">strs</span><span id="errLabel-2531-112-4" role="tooltip" class="error-tooltip">Object is possibly 'null'.</span></span>) {
            <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>)
        }
    }
    <span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"string"</span>) {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">strs</span>)
    }
    <span class="tm-kw">else</span> {
        <span class="tm-cmt">// do nothing</span>
    }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'null'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printAll(strs%3A%20string%20%7C%20string%5B%5D%20%7C%20null)%20%7B%0A%20%20%20%20if%20(typeof%20strs%20%3D%3D%3D%20%22object%22)%20%7B%0A%20%20%20%20%20%20%20%20for%20(const%20s%20of%20strs)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(s)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20else%20if%20(typeof%20strs%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%20%20%20%20console.log(strs)%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20do%20nothing%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>In the <code>printAll</code> function, we try to check if <code>strs</code> is an object to see if it's an array type (now might be a good time to reinforce that arrays are object types in JavaScript).
But it turns out that in JavaScript, <code>typeof null</code> is actually <code>"object"</code>!
This is one of those unfortunate accidents of history.</p>
<p>Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that <code>strs</code> was only narrowed down to <code>string[] | null</code> instead of just <code>string[]</code>.</p>
<p>This might be a good segue into what we'll call "truthiness" checking.</p>
<h1 id="truthiness-narrowing"><a href="#truthiness-narrowing">Truthiness narrowing</h1></a>
<p>Truthiness might not be a word you'll find in the dictionary, but it's very much something you'll hear about in JavaScript.</p>
<!-- TODO: I'm on an airplane, is truthiness in the dictionary?? -->
<p>In JavaScript, we can use any expression in conditionals, <code>&amp;&amp;</code>s, <code>||</code>s, <code>if</code> statements, and Boolean negations (<code>!</code>), and more.
As an example, <code>if</code> statements don't expect their condition to always have the type <code>boolean</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">getUsersOnlineMessage</span>(<span class="tm-vr">numUsersOnline</span>: <span class="tm-typ">number</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">numUsersOnline</span>) {
        <span class="tm-kw">return</span> <span class="tm-str">`There are </span><span class="tm-kw">${</span><span class="tm-vr">numUsersOnline</span><span class="tm-kw">}</span><span class="tm-str"> online now!`</span>;
    }
    <span class="tm-kw">return</span> <span class="tm-str">"Nobody's here. :("</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20getUsersOnlineMessage(numUsersOnline%3A%20number)%20%7B%0A%20%20%20%20if%20(numUsersOnline)%20%7B%0A%20%20%20%20%20%20%20%20return%20%60There%20are%20%24%7BnumUsersOnline%7D%20online%20now!%60%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20%22Nobody's%20here.%20%3A(%22%3B%0A%7D">Try</a></pre></p>
<p>In JavaScript, constructs like<code>if</code> first "coerce" their conditions to <code>boolean</code>s to make sense of them, and then choose their branches depending on whether the result is <code>true</code> or <code>false</code>.
Values like</p>
<ul>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>""</code> (the empty string)</li>
<li><code>0n</code> (the <code>bigint</code> version of zero)</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<p>all coerce to <code>false</code>, and other values get coerced <code>true</code>.
You can always coerce values to <code>boolean</code>s by running them through the <code>Boolean</code> function, or by using the shorter double-Boolean negation.</p>
<p><pre class="typescript-code"><span class="tm-cmt">// both of these result in 'true'</span>
<span class="tm-typ">Boolean</span>(<span class="tm-str">"hello"</span>);
!!<span class="tm-str">"world"</span>;<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20both%20of%20these%20result%20in%20'true'%0ABoolean(%22hello%22)%3B%0A!!%22world%22%3B">Try</a></pre></p>
<p>It's fairly popular to leverage this behavior, especially for guarding against values like <code>null</code> or <code>undefined</code>.
As an example, let's try using it for our <code>printAll</code> function.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printAll</span>(<span class="tm-vr">strs</span>: <span class="tm-typ">string</span> | <span class="tm-typ">string</span>[] | <span class="tm-typ">null</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">strs</span> && <span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"object"</span>) {
        <span class="tm-kw">for</span> (<span class="tm-kw">const</span> <span class="tm-vr">s</span> <span class="tm-kw">of</span> <span class="tm-vr">strs</span>) {
            <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>)
        }
    }
    <span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"string"</span>) {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">strs</span>)
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printAll(strs%3A%20string%20%7C%20string%5B%5D%20%7C%20null)%20%7B%0A%20%20%20%20if%20(strs%20%26%26%20typeof%20strs%20%3D%3D%3D%20%22object%22)%20%7B%0A%20%20%20%20%20%20%20%20for%20(const%20s%20of%20strs)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(s)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20else%20if%20(typeof%20strs%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%20%20%20%20console.log(strs)%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>You'll notice that we've gotten rid of the error above by checking if <code>strs</code> is truthy.
This at least prevents us from dreaded errors when we run our code like:</p>
<pre><code class="txt language-txt">TypeError: null is not iterable
</code></pre>
<p>Keep in mind though that truthiness checking on primitives can often be error prone.
As an example, consider a different attempt at writing <code>printAll</code></p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printAll</span>(<span class="tm-vr">strs</span>: <span class="tm-typ">string</span> | <span class="tm-typ">string</span>[] | <span class="tm-typ">null</span>) {
    <span class="tm-cmt">// !!!!!!!!!!!!!!!!</span>
    <span class="tm-cmt">//  DON'T DO THIS!</span>
    <span class="tm-cmt">//   KEEP READING</span>
    <span class="tm-cmt">// !!!!!!!!!!!!!!!!</span>
    <span class="tm-kw">if</span> (<span class="tm-vr">strs</span>) {
        <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"object"</span>) {
            <span class="tm-kw">for</span> (<span class="tm-kw">const</span> <span class="tm-vr">s</span> <span class="tm-kw">of</span> <span class="tm-vr">strs</span>) {
                <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>)
            }
        }
        <span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"string"</span>) {
            <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">strs</span>)
        }
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printAll(strs%3A%20string%20%7C%20string%5B%5D%20%7C%20null)%20%7B%0A%20%20%20%20%2F%2F%20!!!!!!!!!!!!!!!!%0A%20%20%20%20%2F%2F%20%20DON'T%20DO%20THIS!%0A%20%20%20%20%2F%2F%20%20%20KEEP%20READING%0A%20%20%20%20%2F%2F%20!!!!!!!!!!!!!!!!%0A%20%20%20%20if%20(strs)%20%7B%0A%20%20%20%20%20%20%20%20if%20(typeof%20strs%20%3D%3D%3D%20%22object%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20(const%20s%20of%20strs)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20console.log(s)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20else%20if%20(typeof%20strs%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(strs)%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.</p>
<p>TypeScript doesn't hurt us here at all, but this is behavior worth noting if you're less familiar with JavaScript.
TypeScript can often help you catch bugs early on, but if you choose to do <em>nothing</em> with a value, there's only so much that it can do without being overly prescriptive.
If you want, you can make sure you handle situations like these with a linter.</p>
<p>One last word on narrowing by truthiness is that Boolean negations with <code>!</code> filter out from negated branches.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">multiplyAll</span>(<span class="tm-vr">values</span>: <span class="tm-typ">number</span>[] | <span class="tm-typ">undefined</span>, <span class="tm-vr">factor</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> number[] </span>|<span class="tm-typ"> undefined </span>{
    <span class="tm-kw">if</span> (!<span class="tm-vr">values</span>) {
        <span class="tm-kw">return</span> <span class="tm-vr">values</span>;
    }
    <span class="tm-kw">else</span> {
        <span class="tm-kw">return</span> <span class="tm-vr">values</span>.<span class="tm-mth">map</span>(<span class="tm-vr">x</span> <span class="tm-kw">=></span> <span class="tm-vr">x</span> * <span class="tm-vr">factor</span>);
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20multiplyAll(values%3A%20number%5B%5D%20%7C%20undefined%2C%20factor%3A%20number)%3A%20number%5B%5D%20%7C%20undefined%20%7B%0A%20%20%20%20if%20(!values)%20%7B%0A%20%20%20%20%20%20%20%20return%20values%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20return%20values.map(x%20%3D%3E%20x%20*%20factor)%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="equality-narrowing"><a href="#equality-narrowing">Equality narrowing</h2></a>
<p>TypeScript also uses <code>switch</code> statements and equality checks like <code>===</code>, <code>!==</code>, <code>==</code>, and <code>!=</code> to narrow types.
For example:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">foo</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span>, <span class="tm-vr">y</span>: <span class="tm-typ">string</span> | <span class="tm-typ">boolean</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">x</span> === <span class="tm-vr">y</span>) {
        <span class="tm-cmt">// We can now call any 'string' method on 'x' or 'y'.</span>
        <span class="tm-vr">x</span>.<span class="tm-mth">toUpperCase</span>();
        <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
        <span class="tm-vr">y</span>.<span class="tm-mth">toLowerCase</span>();
        <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">y</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
    }
    <span class="tm-kw">else</span> {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span>
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">y</span>);
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">y</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">boolean</span></span>
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20foo(x%3A%20string%20%7C%20number%2C%20y%3A%20string%20%7C%20boolean)%20%7B%0A%20%20%20%20if%20(x%20%3D%3D%3D%20y)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20We%20can%20now%20call%20any%20'string'%20method%20on%20'x'%20or%20'y'.%0A%20%20%20%20%20%20%20%20x.toUpperCase()%3B%0A%20%20%20%20%20%20%20%20y.toLowerCase()%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20console.log(x)%3B%0A%20%20%20%20%20%20%20%20console.log(y)%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>When we checked that <code>x</code> and <code>y</code> are both equal in the above example, TypeScript knew their types also had to be equal.
Since <code>string</code> is the only common type that both <code>x</code> and <code>y</code> could take on, TypeScript knows that <code>x</code> and <code>y</code> must be a <code>string</code> in the first branch.</p>
<p>Checking against specific literal values (as opposed to variables) works also.
In our section about truthiness narrowing, we wrote a <code>printAll</code> function which was error-prone because it accidentally didn't handle empty strings properly.
Instead we could have done a specific check to block out <code>null</code>s, and TypeScript still correctly removes <code>null</code> from the type of <code>strs</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">printAll</span>(<span class="tm-vr">strs</span>: <span class="tm-typ">string</span> | <span class="tm-typ">string</span>[] | <span class="tm-typ">null</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">strs</span> !== <span class="tm-kw">null</span>) {
        <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"object"</span>) {
            <span class="tm-kw">for</span> (<span class="tm-kw">const</span> <span class="tm-vr">s</span> <span class="tm-kw">of</span> <span class="tm-vr">strs</span>) {
                            <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">strs</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="punctuation">[</span><span class="punctuation">]</span></span>
                <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>);
            }
        }
        <span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">strs</span> === <span class="tm-str">"string"</span>) {
            <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">strs</span>);
                        <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">strs</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
        }
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20printAll(strs%3A%20string%20%7C%20string%5B%5D%20%7C%20null)%20%7B%0A%20%20%20%20if%20(strs%20!%3D%3D%20null)%20%7B%0A%20%20%20%20%20%20%20%20if%20(typeof%20strs%20%3D%3D%3D%20%22object%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20(const%20s%20of%20strs)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20console.log(s)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20else%20if%20(typeof%20strs%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(strs)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>JavaScript's looser equality checks with <code>==</code> and <code>!=</code> also get narrowed correctly.
If you're unfamiliar, checking whether something <code>== null</code> actually not only checks whether it is specifically the value <code>null</code> - it also checks whether it's potentially <code>undefined</code>.
The same applies to <code>== undefined</code>: it checks whether a value is either <code>null</code> or <code>undefined</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Container</span></span> {
    <span class="tm-vr">value</span>: <span class="tm-typ">number</span> | <span class="tm-typ">null</span> | <span class="tm-typ">undefined</span>
}

<span class="tm-kw">function</span> <span class="tm-mth">multiplyValue</span>(<span class="tm-vr">container</span>: <span class="tm-typ"><span class="interfaceName">Container</span></span>, <span class="tm-vr">factor</span>: <span class="tm-typ">number</span>) {
    <span class="tm-cmt">// Remove both 'null' and 'undefined' from the type.</span>
    <span class="tm-kw">if</span> (<span class="tm-vr">container</span>.<span class="tm-vr">value</span> != <span class="tm-kw">null</span>) {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">container</span>.<span class="tm-vr">value</span>);
                              <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">property</span><span class="punctuation">)</span><span class="space"> </span><span class="interfaceName">Container</span><span class="punctuation">.</span><span class="propertyName">value</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>

        <span class="tm-cmt">// Now we can safely multiply 'container.value'.</span>
        <span class="tm-vr">container</span>.<span class="tm-vr">value</span> *= <span class="tm-vr">factor</span>;
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Container%20%7B%0A%20%20%20%20value%3A%20number%20%7C%20null%20%7C%20undefined%0A%7D%0A%0Afunction%20multiplyValue(container%3A%20Container%2C%20factor%3A%20number)%20%7B%0A%20%20%20%20%2F%2F%20Remove%20both%20'null'%20and%20'undefined'%20from%20the%20type.%0A%20%20%20%20if%20(container.value%20!%3D%20null)%20%7B%0A%20%20%20%20%20%20%20%20console.log(container.value)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20Now%20we%20can%20safely%20multiply%20'container.value'.%0A%20%20%20%20%20%20%20%20container.value%20*%3D%20factor%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="instanceof-narrowing"><a href="#instanceof-narrowing"><code>instanceof</code> narrowing</h2></a>
<p>JavaScript has an operator for checking whether or not a value is an "instance" of another value.
More specifically, in JavaScript <code>x instanceof Foo</code> checks whether the <em>prototype chain</em> of <code>x</code> contains <code>Foo.prototype</code>.
While we won't dive deep here, and you'll see more of this when we get into classes, they can still be useful for most values that can be constructed with <code>new</code>.
As you might have guessed, <code>instanceof</code> is also a type guard, and TypeScript narrows in branches guarded by <code>instanceof</code>s.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">logValue</span>(<span class="tm-vr">x</span>: <span class="tm-typ"><span class="interfaceName">Date</span></span> | <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">x</span> <span class="tm-kw">instanceof</span> <span class="tm-typ">Date</span>) {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>.<span class="tm-mth">toUTCString</span>());
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="localName">Date</span></span>
    }
    <span class="tm-kw">else</span> {
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>.<span class="tm-mth">toUpperCase</span>());
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20logValue(x%3A%20Date%20%7C%20string)%20%7B%0A%20%20%20%20if%20(x%20instanceof%20Date)%20%7B%0A%20%20%20%20%20%20%20%20console.log(x.toUTCString())%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20console.log(x.toUpperCase())%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="assignments"><a href="#assignments">Assignments</h2></a>
<p>As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">x</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() < <span class="tm-num">0.5</span> ? <span class="tm-num">10</span> : <span class="tm-str">"hello world!"</span>;
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span>
<span class="tm-vr">x</span> = <span class="tm-num">1</span>;

<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
            <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>
<span class="tm-vr">x</span> = <span class="tm-str">"goodbye!"</span>;

<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
            <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20x%20%3D%20Math.random()%20%3C%200.5%20%3F%2010%20%3A%20%22hello%20world!%22%3B%0Ax%20%3D%201%3B%0A%0Aconsole.log(x)%3B%0Ax%20%3D%20%22goodbye!%22%3B%0A%0Aconsole.log(x)%3B">Try</a></pre></p>
<p>Notice that each of these assignments is valid.
Even though the observed type of <code>x</code> changed to <code>number</code> after our first assignment, we were still able to assign a <code>string</code> to <code>x</code>.
This is because the <em>declared type</em> of <code>x</code> - the type that <code>x</code> started with - is <code>string | number</code>, and assignability is always checked against the declared type.</p>
<p>If we'd assigned a <code>boolean</code> to <code>x</code>, we'd have seen an error since that wasn't part of the declared type.</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">x</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() < <span class="tm-num">0.5</span> ? <span class="tm-num">10</span> : <span class="tm-str">"hello world!"</span>;
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span>
<span class="tm-vr">x</span> = <span class="tm-num">1</span>;

<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
            <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>
<span class="error" tabindex="0" aria-describedby="errLabel-2322-75-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2322-75-1" role="tooltip" class="error-tooltip">Type 'true' is not assignable to type 'string | number'.</span></span> = <span class="tm-kw">true</span>;

<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
            <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span><hr class="error-divider"><div class="listed-error"><div class="error-line">Type 'true' is not assignable to type 'string | number'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20x%20%3D%20Math.random()%20%3C%200.5%20%3F%2010%20%3A%20%22hello%20world!%22%3B%0Ax%20%3D%201%3B%0A%0Aconsole.log(x)%3B%0Ax%20%3D%20true%3B%0A%0Aconsole.log(x)%3B">Try</a></pre></p>
<h2 id="control-flow-analysis"><a href="#control-flow-analysis">Control flow analysis</h2></a>
<p>Up until this point, we've gone through some basic examples of how TypeScript narrows within specific branches.
But there's a bit more going on than just walking up from every variable and looking for type guards in <code>if</code>s, <code>while</code>s, conditionals, etc.
For example</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">padLeft</span>(<span class="tm-vr">padding</span>: <span class="tm-typ">number</span> | <span class="tm-typ">string</span>, <span class="tm-vr">input</span>: <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">padding</span> === <span class="tm-str">"number"</span>) {
        <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Array</span>(<span class="tm-vr">padding</span> + <span class="tm-num">1</span>).<span class="tm-mth">join</span>(<span class="tm-str">" "</span>) + <span class="tm-vr">input</span>;
    }
    <span class="tm-kw">return</span> <span class="tm-vr">padding</span> + <span class="tm-vr">input</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20padLeft(padding%3A%20number%20%7C%20string%2C%20input%3A%20string)%20%7B%0A%20%20%20%20if%20(typeof%20padding%20%3D%3D%3D%20%22number%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20new%20Array(padding%20%2B%201).join(%22%20%22)%20%2B%20input%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20padding%20%2B%20input%3B%0A%7D">Try</a></pre></p>
<p><code>padLeft</code> returns from within its first <code>if</code> block.
TypeScript was able to analyze this code and see that the rest of the body (<code>return padding + input;</code>) is <em>unreachable</em> in the case where <code>padding</code> is a <code>number</code>.
As a result, it was able to remove <code>number</code> from the type of <code>padding</code> (narrowing from <code>string | number</code> to <code>string</code>) for the rest of the function.</p>
<p>This analysis of code based on reachability is called <em>control flow analysis</em>, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments.
When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">foo</span>() {
    <span class="tm-kw">let</span> <span class="tm-vr">x</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span> | <span class="tm-typ">boolean</span>;

    <span class="tm-vr">x</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() < <span class="tm-num">0.5</span>;

    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
                <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">boolean</span></span>

    <span class="tm-kw">if</span> (<span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() < <span class="tm-num">0.5</span>) {
        <span class="tm-vr">x</span> = <span class="tm-str">"hello"</span>;
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span>
    }
    <span class="tm-kw">else</span> {
        <span class="tm-vr">x</span> = <span class="tm-num">100</span>;
        <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">x</span>);
                    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>
    }

    <span class="tm-kw">return</span> <span class="tm-vr">x</span>;
           <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20foo()%20%7B%0A%20%20%20%20let%20x%3A%20string%20%7C%20number%20%7C%20boolean%3B%0A%0A%20%20%20%20x%20%3D%20Math.random()%20%3C%200.5%3B%0A%0A%20%20%20%20console.log(x)%3B%0A%0A%20%20%20%20if%20(Math.random()%20%3C%200.5)%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20%22hello%22%3B%0A%20%20%20%20%20%20%20%20console.log(x)%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20100%3B%0A%20%20%20%20%20%20%20%20console.log(x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20return%20x%3B%0A%7D">Try</a></pre></p>
<h1 id="discriminated-unions"><a href="#discriminated-unions">Discriminated unions</h1></a>
<p>Most of the examples we've looked at so far have focused around narrowing single variables with simple types like <code>string</code>, <code>boolean</code>, and <code>number</code>.
While this is common, most of the time in JavaScript we'll be dealing with slightly more complex structures.</p>
<p>For some motivation, let's imagine we're trying to encode shapes like circles and squares.
Circles keep track of their radii and squares keep track of their side lengths.
We'll use a field called <code>kind</code> to tell which shape we're dealing with.
Here's a first attempt at defining <code>Shape</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Shape</span></span> {
    <span class="tm-vr">kind</span>: <span class="tm-str">"circle"</span> | <span class="tm-str">"square"</span>;
    <span class="tm-vr">radius</span>?: <span class="tm-typ">number</span>;
    <span class="tm-vr">sideLength</span>?: <span class="tm-typ">number</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Shape%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%20%7C%20%22square%22%3B%0A%20%20%20%20radius%3F%3A%20number%3B%0A%20%20%20%20sideLength%3F%3A%20number%3B%0A%7D">Try</a></pre></p>
<p>Notice we're using a union of string literal types: <code>"circle"</code> and <code>"square"</code> to tell us whether we should treat the shape as a circle or square respectively.
By using <code>"circle" | "square"</code> instead of <code>string</code>,  we can avoid misspelling issues.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">handleShape</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="interfaceName">Shape</span></span>) {
    <span class="tm-cmt">// oops!</span>
    <span class="tm-kw">if</span> (<span class="error" tabindex="0" aria-describedby="errLabel-2367-162-21"><span class="error-highlight"></span><span class="tm-vr">shape</span>.<span class="tm-vr">kind</span> === <span class="tm-str">"rect"</span><span id="errLabel-2367-162-21" role="tooltip" class="error-tooltip">This condition will always return 'false' since the types '"circle" | "square"' and '"rect"' have no overlap.</span></span>) {
        <span class="tm-cmt">// ...</span>
    }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">This condition will always return 'false' since the types '"circle" | "square"' and '"rect"' have no overlap.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Shape%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%20%7C%20%22square%22%3B%0A%20%20%20%20radius%3F%3A%20number%3B%0A%20%20%20%20sideLength%3F%3A%20number%3B%0A%7D%0A%0A%2F%2Fcut%0Afunction%20handleShape(shape%3A%20Shape)%20%7B%0A%20%20%20%20%2F%2F%20oops!%0A%20%20%20%20if%20(shape.kind%20%3D%3D%3D%20%22rect%22)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20...%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>We can write a <code>getArea</code> function that applies the right logic based on if it's dealing with a circle or square.
We'll first try dealing with circles.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="interfaceName">Shape</span></span>) {
    <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="error" tabindex="0" aria-describedby="errLabel-2532-158-12"><span class="error-highlight"></span><span class="tm-vr">shape</span>.<span class="tm-vr">radius</span><span id="errLabel-2532-158-12" role="tooltip" class="error-tooltip">Object is possibly 'undefined'.</span></span> ** <span class="tm-num">2</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'undefined'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Shape%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%20%7C%20%22square%22%3B%0A%20%20%20%20radius%3F%3A%20number%3B%0A%20%20%20%20sideLength%3F%3A%20number%3B%0A%7D%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%7D">Try</a></pre></p>
<!-- TODO -->
<p>Under <code>strictNullChecks</code> that gives us an error - which is appropriate since <code>radius</code> might not be defined.
But what if we perform the appropriate checks on the <code>kind</code> property?</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="interfaceName">Shape</span></span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">shape</span>.<span class="tm-vr">kind</span> === <span class="tm-str">"circle"</span>) {
        <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="error" tabindex="0" aria-describedby="errLabel-2532-197-12"><span class="error-highlight"></span><span class="tm-vr">shape</span>.<span class="tm-vr">radius</span><span id="errLabel-2532-197-12" role="tooltip" class="error-tooltip">Object is possibly 'undefined'.</span></span> ** <span class="tm-num">2</span>;
    }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'undefined'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Shape%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%20%7C%20%22square%22%3B%0A%20%20%20%20radius%3F%3A%20number%3B%0A%20%20%20%20sideLength%3F%3A%20number%3B%0A%7D%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20if%20(shape.kind%20%3D%3D%3D%20%22circle%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>Hmm, TypeScript still doesn't know what to do here.
We've hit a point where we know more about our values than the type checker does.
We could try to use a non-null assertion (a <code>!</code> after <code>shape.radius</code>) to say that <code>radius</code> is definitely present.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="interfaceName">Shape</span></span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">shape</span>.<span class="tm-vr">kind</span> === <span class="tm-str">"circle"</span>) {
        <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="tm-vr">shape</span>.<span class="tm-vr">radius</span>! ** <span class="tm-num">2</span>;
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Shape%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%20%7C%20%22square%22%3B%0A%20%20%20%20radius%3F%3A%20number%3B%0A%20%20%20%20sideLength%3F%3A%20number%3B%0A%7D%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20if%20(shape.kind%20%3D%3D%3D%20%22circle%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20Math.PI%20*%20shape.radius!%20**%202%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>But this doesn't feel ideal.
We had to shout a bit at the type-checker with those non-null assertions (<code>!</code>) to convince it that <code>shape.radius</code> was defined, but those assertions are error-prone if we start to move code around.
Additionally, outside of <code>strictNullChecks</code> we're able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them).
We can definitely do better.</p>
<p>The problem with this encoding of <code>Shape</code> is that the type-checker doesn't have any way to know whether or not <code>radius</code> or <code>sideLength</code> are present based on the <code>kind</code> property.
We need to communicate what <em>we</em> know to the type checker.
With that in mind, let's take another swing at defining <code>Shape</code>.</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Circle</span></span> {
    <span class="tm-vr">kind</span>: <span class="tm-str">"circle"</span>;
    <span class="tm-vr">radius</span>: <span class="tm-typ">number</span>;
}

<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Square</span></span> {
    <span class="tm-vr">kind</span>: <span class="tm-str">"square"</span>;
    <span class="tm-vr">sideLength</span>: <span class="tm-typ">number</span>;
}

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Shape</span></span> = <span class="tm-typ"><span class="interfaceName">Circle</span></span> | <span class="tm-typ"><span class="interfaceName">Square</span></span>;<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Circle%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%3B%0A%20%20%20%20radius%3A%20number%3B%0A%7D%0A%0Ainterface%20Square%20%7B%0A%20%20%20%20kind%3A%20%22square%22%3B%0A%20%20%20%20sideLength%3A%20number%3B%0A%7D%0A%0Atype%20Shape%20%3D%20Circle%20%7C%20Square%3B">Try</a></pre></p>
<p>Here, we've properly separated <code>Shape</code> out into two types with different values for the <code>kind</code> property, but <code>radius</code> and <code>sideLength</code> are declared as required properties in their respective types.</p>
<p>Let's see what happens here when we try to access the <code>radius</code> of a <code>Shape</code>.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="typeAliasName">Shape</span></span>) {
    <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="tm-vr">shape</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2339-225-6"><span class="error-highlight"></span><span class="tm-vr">radius</span><span id="errLabel-2339-225-6" role="tooltip" class="error-tooltip">Property 'radius' does not exist on type 'Shape'.
  Property 'radius' does not exist on type 'Square'.</span></span> ** <span class="tm-num">2</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'radius' does not exist on type 'Shape'.</div><div class="error-line"><div class="indent"></div>Property 'radius' does not exist on type 'Square'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Circle%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%3B%0A%20%20%20%20radius%3A%20number%3B%0A%7D%0A%0Ainterface%20Square%20%7B%0A%20%20%20%20kind%3A%20%22square%22%3B%0A%20%20%20%20sideLength%3A%20number%3B%0A%7D%0A%0Atype%20Shape%20%3D%20Circle%20%7C%20Square%3B%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%7D">Try</a></pre></p>
<p>Like with our first definition of <code>Shape</code>, this is still an error.
When <code>radius</code> was optional, we got an error (only in <code>strictNullChecks</code>) because TypeScript couldn't tell whether the property was present.
Now that <code>Shape</code> is a union, TypeScript is telling us that <code>shape</code> might be a <code>Square</code>, and <code>Square</code>s don't have <code>radius</code> defined on them!
Both interpretations are correct, but only does our new encoding of <code>Shape</code> still cause an error outside of <code>strictNullChecks</code>.</p>
<p>But what if we tried checking the <code>kind</code> property again?</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="typeAliasName">Shape</span></span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">shape</span>.<span class="tm-vr">kind</span> === <span class="tm-str">"circle"</span>) {
        <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="tm-vr">shape</span>.<span class="tm-vr">radius</span> ** <span class="tm-num">2</span>;
                         <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">shape</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">Circle</span></span>
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Circle%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%3B%0A%20%20%20%20radius%3A%20number%3B%0A%7D%0A%0Ainterface%20Square%20%7B%0A%20%20%20%20kind%3A%20%22square%22%3B%0A%20%20%20%20sideLength%3A%20number%3B%0A%7D%0A%0Atype%20Shape%20%3D%20Circle%20%7C%20Square%3B%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20if%20(shape.kind%20%3D%3D%3D%20%22circle%22)%20%7B%0A%20%20%20%20%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>That got rid of the error!
When every type in a union contains a common property with literal types, TypeScript considers that to be a <em>discriminated union</em>, and can narrow out the members of the union.</p>
<p>In this case, <code>kind</code> was that common property (which is what's considered a <em>discriminant</em> property of <code>Shape</code>).
Checking whether the <code>kind</code> property was <code>"circle"</code> got rid of every type in <code>Shape</code> that didn't have a <code>kind</code> property with the type <code>"circle"</code>.
That narrowed <code>shape</code> down to the type <code>Circle</code>.</p>
<p>The same checking works with <code>switch</code> statements as well.
Now we can try to write our complete <code>getArea</code> without any pesky <code>!</code> non-null assertions.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="typeAliasName">Shape</span></span>) {
    <span class="tm-kw">switch</span> (<span class="tm-vr">shape</span>.<span class="tm-vr">kind</span>) {
        <span class="tm-kw">case</span> <span class="tm-str">"circle"</span>:
            <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="tm-vr">shape</span>.<span class="tm-vr">radius</span> ** <span class="tm-num">2</span>;
                             <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">shape</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">Circle</span></span>
        <span class="tm-kw">case</span> <span class="tm-str">"square"</span>:
            <span class="tm-kw">return</span> <span class="tm-vr">shape</span>.<span class="tm-vr">sideLength</span> ** <span class="tm-num">2</span>;
                   <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">shape</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">Square</span></span>
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Circle%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%3B%0A%20%20%20%20radius%3A%20number%3B%0A%7D%0A%0Ainterface%20Square%20%7B%0A%20%20%20%20kind%3A%20%22square%22%3B%0A%20%20%20%20sideLength%3A%20number%3B%0A%7D%0A%0Atype%20Shape%20%3D%20Circle%20%7C%20Square%3B%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20switch%20(shape.kind)%20%7B%0A%20%20%20%20%20%20%20%20case%20%22circle%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%20%20%20%20%20%20%20%20case%20%22square%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20shape.sideLength%20**%202%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>The important thing here was the encoding of <code>Shape</code>.
Communicating the right information to TypeScript - that <code>Circle</code> and <code>Square</code> were really two separate types with specific <code>kind</code> fields - was crucial.
Doing that let us write type-safe TypeScript code that looks no different than the JavaScript we would've written otherwise.
From there, the type system was able to do the "right" thing and figure out the types in each branch of our <code>switch</code> statement.</p>
<blockquote>
  <p>As an aside, try playing around with the above example and remove some of the return keywords.
  You'll see that type-checking can help avoid bugs when accidentally falling through different clauses in a <code>switch</code> statement.</p>
</blockquote>
<p>Discriminated unions are useful for more than just talking about circles and squares.
They're good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.</p>
<h1 id="the-never-type"><a href="#the-never-type">The <code>never</code> type</h1></a>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">getArea</span>(<span class="tm-vr">shape</span>: <span class="tm-typ"><span class="typeAliasName">Shape</span></span>) {
    <span class="tm-kw">switch</span> (<span class="tm-vr">shape</span>.<span class="tm-vr">kind</span>) {
        <span class="tm-kw">case</span> <span class="tm-str">"circle"</span>:
            <span class="tm-kw">return</span> <span class="tm-typ">Math</span>.PI * <span class="tm-vr">shape</span>.<span class="tm-vr">radius</span> ** <span class="tm-num">2</span>;
        <span class="tm-kw">case</span> <span class="tm-str">"square"</span>:
            <span class="tm-kw">return</span> <span class="tm-vr">shape</span>.<span class="tm-vr">sideLength</span> ** <span class="tm-num">2</span>;
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Circle%20%7B%0A%20%20%20%20kind%3A%20%22circle%22%3B%0A%20%20%20%20radius%3A%20number%3B%0A%7D%0A%0Ainterface%20Square%20%7B%0A%20%20%20%20kind%3A%20%22square%22%3B%0A%20%20%20%20sideLength%3A%20number%3B%0A%7D%0A%0Atype%20Shape%20%3D%20Circle%20%7C%20Square%3B%0A%0A%2F%2Fcut%0Afunction%20getArea(shape%3A%20Shape)%20%7B%0A%20%20%20%20switch%20(shape.kind)%20%7B%0A%20%20%20%20%20%20%20%20case%20%22circle%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Math.PI%20*%20shape.radius%20**%202%3B%0A%20%20%20%20%20%20%20%20case%20%22square%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20shape.sideLength%20**%202%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<!-- TODO -->
<h1 id="exhaustiveness-checking"><a href="#exhaustiveness-checking">Exhaustiveness checking</h1></a>
<!-- TODO -->
<!--
As another example, consider a `setVisible` function, that takes an `HTMLElement` and either takes a `boolean` to set whether or not the element is visible on the page, or a `number` to adjust the element's opacity (i.e. how non-transparent it is).

<pre class="typescript-code"></pre>
--><hr><h1 id="more-on-functions"><a href="#more-on-functions">More on Functions</h1></a>
<p>Functions are the basic building block of any application, whether they're local functions, imported from another module, or methods on a class.
They're also values, and just like other values, TypeScript has many ways to describe how functions can be called.
Let's learn about how to write types that describe functions.</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#function-type-expressions">Function Type Expressions</a></li><li><a href="#call-signatures">Call Signatures</a></li><li><a href="#construct-signatures">Construct Signatures</a></li><li><a href="#generic-functions">Generic Functions</a></li><ul><li><a href="#inference">Inference</a></li><li><a href="#constraints">Constraints</a></li><li><a href="#working-with-constrained-values">Working with Constrained Values</a></li><li><a href="#specifying-type-arguments">Specifying Type Arguments</a></li><li><a href="#guidelines-for-writing-good-generic-functions">Guidelines for Writing Good Generic Functions</a></li><ul><li><a href="#push-type-parameters-down">Push Type Parameters Down</a></li><li><a href="#use-fewer-type-parameters">Use Fewer Type Parameters</a></li><li><a href="#type-parameters-should-appear-twice">Type Parameters Should Appear Twice</a></li></ul></ul><li><a href="#optional-parameters">Optional Parameters</a></li><ul><li><a href="#optional-parameters-in-callbacks">Optional Parameters in Callbacks</a></li></ul><li><a href="#function-overloads">Function Overloads</a></li><ul><li><a href="#overload-signatures-and-the-implementation-signature">Overload Signatures and the Implementation Signature</a></li><li><a href="#writing-good-overloads">Writing Good Overloads</a></li></ul><li><a href="#other-types-to-know-about">Other Types to Know About</a></li><ul><li><a href="#void"><code>void</code></a></li><li><a href="#object"><code>object</code></a></li><li><a href="#unknown"><code>unknown</code></a></li><li><a href="#never"><code>never</code></a></li><li><a href="#the-global-function-type"><code>Function</code></a></li></ul><li><a href="#rest-parameters-and-arguments">Rest Parameters and Arguments</a></li><ul><li><a href="#rest-parameters">Rest Parameters</a></li><li><a href="#rest-arguments">Rest Arguments</a></li></ul><li><a href="#parameter-destructuring">Parameter Destructuring</a></li><li><a href="#assignability-of-functions">Assignability of Functions</a></li></ul></ul></div>
<h2 id="function-type-expressions"><a href="#function-type-expressions">Function Type Expressions</h2></a>
<p>The simplest way to describe a function is with a a <em>function type expression</em>.
These types are syntactically similar to arrow functions:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greeter</span>(<span class="tm-mth">fn</span>: (<span class="tm-vr">a</span>: <span class="tm-typ">string</span>) <span class="tm-kw">=></span> <span class="tm-typ">void</span>) {
    <span class="tm-mth">fn</span>(<span class="tm-str">"Hello, World"</span>);
}
<span class="tm-kw">function</span> <span class="tm-mth">printToConsole</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>);
}
<span class="tm-mth">greeter</span>(<span class="tm-vr">printToConsole</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greeter(fn%3A%20(a%3A%20string)%20%3D%3E%20void)%20%7B%0A%20%20%20%20fn(%22Hello%2C%20World%22)%3B%0A%7D%0Afunction%20printToConsole(s%3A%20string)%20%7B%0A%20%20%20%20console.log(s)%3B%0A%7D%0Agreeter(printToConsole)%3B">Try</a></pre></p>
<p>The syntax <code>(a: string) =&gt; void</code> means "a function with one parameter, named <code>a</code>, of type string, that doesn't have a return value".
Just like with function declarations, if a parameter type isn't specified, it's implicitly <code>any</code>.</p>
<blockquote>
  <p>Note that the parameter name is <strong>required</strong>. The function type <code>(string) =&gt; void</code> means "a function with a parameter named <code>string</code> of type <code>a</code>"!</p>
</blockquote>
<p>Of course, we can use a type alias to name a function type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">GreetFunction</span></span> = (<span class="tm-vr">a</span>: <span class="tm-typ">string</span>) <span class="tm-kw">=></span> <span class="tm-typ">void</span>;
<span class="tm-kw">function</span> <span class="tm-mth">greeter</span>(<span class="tm-vr">fn</span>: <span class="tm-typ"><span class="typeAliasName">GreetFunction</span></span>) {
    <span class="tm-cmt">// ...</span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20GreetFunction%20%3D%20(a%3A%20string)%20%3D%3E%20void%3B%0Afunction%20greeter(fn%3A%20GreetFunction)%20%7B%0A%20%20%20%20%2F%2F%20...%0A%7D">Try</a></pre></p>
<h2 id="call-signatures"><a href="#call-signatures">Call Signatures</h2></a>
<p>In JavaScript, functions can have properties in addition to being callable.
However, the function type expression syntax doesn't allow for declaring properties.
If we want to describe something callable with properties, we can write a <em>call signature</em> in an object type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">DescribableFunction</span></span> = {
    <span class="tm-vr">description</span>: <span class="tm-typ">string</span>;
    (<span class="tm-vr">someArg</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> boolean</span>;
};
<span class="tm-kw">function</span> <span class="tm-mth">doSomething</span>(<span class="tm-vr">fn</span>: <span class="tm-typ"><span class="typeAliasName">DescribableFunction</span></span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">fn</span>.<span class="tm-vr">description</span> + <span class="tm-str">" returned "</span> + <span class="tm-mth">fn</span>(<span class="tm-num">6</span>));
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20DescribableFunction%20%3D%20%7B%0A%20%20%20%20description%3A%20string%3B%0A%20%20%20%20(someArg%3A%20number)%3A%20boolean%3B%0A%7D%3B%0Afunction%20doSomething(fn%3A%20DescribableFunction)%20%7B%0A%20%20%20%20console.log(fn.description%20%2B%20%22%20returned%20%22%20%2B%20fn(6))%3B%0A%7D">Try</a></pre></p>
<p>Note that the syntax is slightly different compared to a function type expression - use <code>:</code> between the parameter list and the return type rather than <code>=&gt;</code>.</p>
<h2 id="construct-signatures"><a href="#construct-signatures">Construct Signatures</h2></a>
<p>JavaScript functions can also be invoked with the <code>new</code> operator.
TypeScript refers to these as <em>constructors</em> because they usually create a new object.
You can write a <em>construct signature</em> by adding the <code>new</code> keyword in front of a call signature:</p>
<p><pre class="typescript-code">
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">SomeConstructor</span></span> = {
    <span class="tm-kw">new</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> <span class="typeAliasName">SomeObject</span></span>;
}
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">ctor</span>: <span class="tm-typ"><span class="typeAliasName">SomeConstructor</span></span>) {
    <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">ctor</span>(<span class="tm-str">"hello"</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20SomeObject%20%3D%20any%3B%0A%2F%2Fcut%0Atype%20SomeConstructor%20%3D%20%7B%0A%20%20%20%20new(s%3A%20string)%3A%20SomeObject%3B%0A%7D%0Afunction%20fn(ctor%3A%20SomeConstructor)%20%7B%0A%20%20%20%20return%20new%20ctor(%22hello%22)%3B%0A%7D">Try</a></pre></p>
<p>Some objects, like JavaScript's <code>Date</code> object, can be called with or without <code>new</code>.
You can combine call and construct signatures in the same type arbitrarily:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">CallOrConstruct</span></span> {
    <span class="tm-kw">new</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> <span class="interfaceName">Date</span></span>;
    (<span class="tm-vr">n</span>?: <span class="tm-typ">number</span>):<span class="tm-typ"> number</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20CallOrConstruct%20%7B%0A%20%20%20%20new(s%3A%20string)%3A%20Date%3B%0A%20%20%20%20(n%3F%3A%20number)%3A%20number%3B%0A%7D">Try</a></pre></p>
<h2 id="generic-functions"><a href="#generic-functions">Generic Functions</h2></a>
<p>It's common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.
Let's consider for a moment a function that returns the first element of an array:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">firstElement</span>(<span class="tm-vr">arr</span>: <span class="tm-typ">any</span>[]) {
  <span class="tm-kw">return</span> <span class="tm-vr">arr</span>[<span class="tm-num">0</span>];
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20firstElement(arr%3A%20any%5B%5D)%20%7B%0A%20%20return%20arr%5B0%5D%3B%0A%7D">Try</a></pre></p>
<p>This function does its job, but unfortunately has the return type <code>any</code>.
It'd be better if the function returned the type of the array element.</p>
<p>In TypeScript, <em>generics</em> are used when we want to describe a correspondence between two values.
We do this by declaring a <em>type parameter</em> in the function signature:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">firstElement</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[]):<span class="tm-typ"> <span class="typeParameterName">T</span> </span>{
  <span class="tm-kw">return</span> <span class="tm-vr">arr</span>[<span class="tm-num">0</span>];
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20firstElement%3CT%3E(arr%3A%20T%5B%5D)%3A%20T%20%7B%0A%20%20return%20arr%5B0%5D%3B%0A%7D">Try</a></pre></p>
<p>By adding a type parameter <code>T</code> to this function and using it in two places, we've created a link between the input of the function (the array) and the output (the return value).
Now when we call it, a more specific type comes out:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// s is of type 'string'</span>
<span class="tm-kw">const</span> <span class="tm-vr">s</span> = <span class="tm-mth">firstElement</span>([<span class="tm-str">"a"</span>, <span class="tm-str">"b"</span>, <span class="tm-str">"c"</span>]);
<span class="tm-cmt">// n is of type 'number'</span>
<span class="tm-kw">const</span> <span class="tm-vr">n</span> = <span class="tm-mth">firstElement</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>]);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20firstElement%3CT%3E(arr%3A%20T%5B%5D)%3A%20T%3B%0A%2F%2Fcut%0A%2F%2F%20s%20is%20of%20type%20'string'%0Aconst%20s%20%3D%20firstElement(%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%2F%2F%20n%20is%20of%20type%20'number'%0Aconst%20n%20%3D%20firstElement(%5B1%2C%202%2C%203%5D)%3B">Try</a></pre></p>
<h3 id="inference"><a href="#inference">Inference</h3></a>
<p>Note that we didn't have to specify <code>T</code> in this sample.
The type was <em>inferred</em> - chosen automatically - by TypeScript.</p>
<p>We can use multiple type parameters as well.
For example, a standalone version of <code>map</code> would look like this:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">map</span><<span class="tm-typ"><span class="typeParameterName">E</span></span>, <span class="tm-typ"><span class="typeParameterName">O</span></span>>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">E</span></span>[], <span class="tm-mth">func</span>: (<span class="tm-vr">arg</span>: <span class="tm-typ"><span class="typeParameterName">E</span></span>) <span class="tm-kw">=></span> <span class="tm-typ"><span class="typeParameterName">O</span></span>):<span class="tm-typ"> <span class="typeParameterName">O</span>[] </span>{
  <span class="tm-kw">return</span> <span class="tm-vr">arr</span>.<span class="tm-mth">map</span>(<span class="tm-vr">func</span>);
}

<span class="tm-cmt">// Parameter 'n' is of type 'number'</span>
<span class="tm-cmt">// 'parsed' is of type 'string[]'</span>
<span class="tm-kw">const</span> <span class="tm-vr">parsed</span> = <span class="tm-mth">map</span>([<span class="tm-str">"1"</span>, <span class="tm-str">"2"</span>, <span class="tm-str">"3"</span>], <span class="tm-vr">n</span> <span class="tm-kw">=></span> <span class="tm-mth">parseInt</span>(<span class="tm-vr">n</span>));<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20map%3CE%2C%20O%3E(arr%3A%20E%5B%5D%2C%20func%3A%20(arg%3A%20E)%20%3D%3E%20O)%3A%20O%5B%5D%20%7B%0A%20%20return%20arr.map(func)%3B%0A%7D%0A%0A%2F%2F%20Parameter%20'n'%20is%20of%20type%20'number'%0A%2F%2F%20'parsed'%20is%20of%20type%20'string%5B%5D'%0Aconst%20parsed%20%3D%20map(%5B%221%22%2C%20%222%22%2C%20%223%22%5D%2C%20n%20%3D%3E%20parseInt(n))%3B">Try</a></pre></p>
<p>Note that in this example, TypeScript could infer both the type of the <code>E</code> type parameter (from the given <code>string</code> array), as well as the type <code>O</code> based on the return value of the function expression.</p>
<h3 id="constraints"><a href="#constraints">Constraints</h3></a>
<p>We've written some generic functions that can work on <em>any</em> kind of value.
Sometimes we want to relate two values, but can only operate on a certain subset of values.
In this case, we can use a <em>constraint</em> to limit the kinds of types that a type parameter can accept.</p>
<p>Let's write a function that returns the longer of two values.
To do this, we need a <code>length</code> property that's a number.
We <em>constrain</em> the type parameter to that type by writing an <code>extends</code> clause:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">longest</span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> { <span class="tm-vr">length</span>: <span class="tm-typ">number</span> }>(<span class="tm-vr">a</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>, <span class="tm-vr">b</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) {
  <span class="tm-kw">if</span> (<span class="tm-vr">a</span>.<span class="tm-vr">length</span> >= <span class="tm-vr">b</span>.<span class="tm-vr">length</span>) {
    <span class="tm-kw">return</span> <span class="tm-vr">a</span>;
  } <span class="tm-kw">else</span> {
    <span class="tm-kw">return</span> <span class="tm-vr">b</span>;
  }
}

<span class="tm-cmt">// longerArray is of type 'number[]'</span>
<span class="tm-kw">const</span> <span class="tm-vr">longerArray</span> = <span class="tm-mth">longest</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>], [<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>]);
<span class="tm-cmt">// longerString is of type 'string'</span>
<span class="tm-kw">const</span> <span class="tm-vr">longerString</span> = <span class="tm-mth">longest</span>(<span class="tm-str">"alice"</span>, <span class="tm-str">"bob"</span>);
<span class="tm-cmt">// Error! Numbers don't have a 'length' property</span>
<span class="tm-kw">const</span> <span class="tm-vr">notOK</span> = <span class="tm-mth">longest</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-375-2"><span class="error-highlight"></span><span class="tm-num">10</span><span id="errLabel-2345-375-2" role="tooltip" class="error-tooltip">Argument of type '10' is not assignable to parameter of type '{ length: number; }'.</span></span>, <span class="tm-num">100</span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type '10' is not assignable to parameter of type '{ length: number; }'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20longest%3CT%20extends%20%7B%20length%3A%20number%20%7D%3E(a%3A%20T%2C%20b%3A%20T)%20%7B%0A%20%20if%20(a.length%20%3E%3D%20b.length)%20%7B%0A%20%20%20%20return%20a%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20b%3B%0A%20%20%7D%0A%7D%0A%0A%2F%2F%20longerArray%20is%20of%20type%20'number%5B%5D'%0Aconst%20longerArray%20%3D%20longest(%5B1%2C%202%5D%2C%20%5B1%2C%202%2C%203%5D)%3B%0A%2F%2F%20longerString%20is%20of%20type%20'string'%0Aconst%20longerString%20%3D%20longest(%22alice%22%2C%20%22bob%22)%3B%0A%2F%2F%20Error!%20Numbers%20don't%20have%20a%20'length'%20property%0Aconst%20notOK%20%3D%20longest(10%2C%20100)%3B">Try</a></pre></p>
<p>There are a interesting few things to note in this example.
We allowed TypeScript to <em>infer</em> the return type of <code>longest</code>.
Return type inference also works on generic functions.</p>
<p>Because we constrained <code>T</code> to <code>{ length: number }</code>, we were allowed to access the <code>.length</code> property of the <code>a</code> and <code>b</code> parameters.
Without the type constraint, we wouldn't be able to access those properties because the values might have been some other type without a length property.</p>
<p>The types of <code>longerArray</code> and <code>longerString</code> were inferred based on the arguments.
Remember, generics are all about relating two or more values with the same type!</p>
<p>Finally, just as we'd like, the call to <code>longest(10, 100)</code> is rejected because the <code>number</code> type doesn't have a <code>.length</code> property.</p>
<h3 id="working-with-constrained-values"><a href="#working-with-constrained-values">Working with Constrained Values</h3></a>
<p>Here's a common error when working with generic constraints:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">minimumLength</span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> { <span class="tm-vr">length</span>: <span class="tm-typ">number</span> }>(<span class="tm-vr">obj</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>, <span class="tm-vr">minimum</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="typeParameterName">T</span> </span>{
  <span class="tm-kw">if</span> (<span class="tm-vr">obj</span>.<span class="tm-vr">length</span> >= <span class="tm-vr">minimum</span>) {
    <span class="tm-kw">return</span> <span class="tm-vr">obj</span>;
  } <span class="tm-kw">else</span> {
    <span class="error" tabindex="0" aria-describedby="errLabel-2322-145-27"><span class="error-highlight"></span><span class="tm-kw">return</span> { <span class="tm-vr">length:</span> <span class="tm-vr">minimum</span> };<span id="errLabel-2322-145-27" role="tooltip" class="error-tooltip">Type '{ length: number; }' is not assignable to type 'T'.</span></span>
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Type '{ length: number; }' is not assignable to type 'T'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20minimumLength%3CT%20extends%20%7B%20length%3A%20number%20%7D%3E(obj%3A%20T%2C%20minimum%3A%20number)%3A%20T%20%7B%0A%20%20if%20(obj.length%20%3E%3D%20minimum)%20%7B%0A%20%20%20%20return%20obj%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20%7B%20length%3A%20minimum%20%7D%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>It might look like this function is OK - <code>T</code> is constrained to <code>{ length: number }</code>, and the function either returns <code>T</code> or a value matching that constraint.
The problem is that the function promises to return the <em>same</em> kind of object as was passed in, not just <em>some</em> object matching the constraint.
If this code were legal, you could write code that definitely wouldn't work:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// 'arr' gets value { length: 6 }</span>
<span class="tm-kw">const</span> <span class="tm-vr">arr</span> = <span class="tm-mth">minimumLength</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>], <span class="tm-num">6</span>);
<span class="tm-cmt">// and crashes here because arrays have</span>
<span class="tm-cmt">// a 'slice' method, but not the returned object!</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">arr</span>.<span class="tm-mth">slice</span>(<span class="tm-num">0</span>));<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20minimumLength%3CT%20extends%20%7B%20length%3A%20number%20%7D%3E(obj%3A%20T%2C%20minimum%3A%20number)%3A%20T%3B%0A%2F%2Fcut%0A%2F%2F%20'arr'%20gets%20value%20%7B%20length%3A%206%20%7D%0Aconst%20arr%20%3D%20minimumLength(%5B1%2C%202%2C%203%5D%2C%206)%3B%0A%2F%2F%20and%20crashes%20here%20because%20arrays%20have%0A%2F%2F%20a%20'slice'%20method%2C%20but%20not%20the%20returned%20object!%0Aconsole.log(arr.slice(0))%3B">Try</a></pre></p>
<h3 id="specifying-type-arguments"><a href="#specifying-type-arguments">Specifying Type Arguments</h3></a>
<p>TypeScript can usually infer the intended type arguments in a generic call, but not always.
For example, let's say you wrote a function to combine two arrays:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">combine</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>>(<span class="tm-vr">arr1</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[], <span class="tm-vr">arr2</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[]):<span class="tm-typ"> <span class="typeParameterName">T</span>[] </span>{
  <span class="tm-kw">return</span> <span class="tm-vr">arr1</span>.<span class="tm-mth">concat</span>(<span class="tm-vr">arr2</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20combine%3CT%3E(arr1%3A%20T%5B%5D%2C%20arr2%3A%20T%5B%5D)%3A%20T%5B%5D%20%7B%0A%20%20return%20arr1.concat(arr2)%3B%0A%7D">Try</a></pre></p>
<p>Normally it would be an error to call this function with mismatched arrays:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">arr</span> = <span class="tm-mth">combine</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>], [<span class="error" tabindex="0" aria-describedby="errLabel-2322-94-7"><span class="error-highlight"></span><span class="tm-str">"hello"</span><span id="errLabel-2322-94-7" role="tooltip" class="error-tooltip">Type 'string' is not assignable to type 'number'.</span></span>]);<hr class="error-divider"><div class="listed-error"><div class="error-line">Type 'string' is not assignable to type 'number'.</div></div></pre></p>
<p>If you intended to do this, however, you could manually specify <code>T</code>:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">arr</span> = <span class="tm-mth">combine</span><<span class="tm-typ">string</span> | <span class="tm-typ">number</span>>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>], [<span class="tm-str">"hello"</span>]);</pre></p>
<h3 id="guidelines-for-writing-good-generic-functions"><a href="#guidelines-for-writing-good-generic-functions">Guidelines for Writing Good Generic Functions</h3></a>
<p>Writing generic functions is fun, and it can be easy to get carried away with type parameters.
Having too many type parameters or using constraints where they aren't needed can make inference less successful, frustrating callers of your function.</p>
<h4 id="push-type-parameters-down"><a href="#push-type-parameters-down">Push Type Parameters Down</h4></a>
<p>Here are two ways of writing a function that appear similar:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">firstElement1</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[]) {
  <span class="tm-kw">return</span> <span class="tm-vr">arr</span>[<span class="tm-num">0</span>];
}

<span class="tm-kw">function</span> <span class="tm-mth">firstElement2</span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> <span class="tm-typ">any</span>[]>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) {
  <span class="tm-kw">return</span> <span class="tm-vr">arr</span>[<span class="tm-num">0</span>];
}

<span class="tm-cmt">// a: number (good)</span>
<span class="tm-kw">const</span> <span class="tm-vr">a</span> = <span class="tm-mth">firstElement1</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>]);
<span class="tm-cmt">// b: any (bad)</span>
<span class="tm-kw">const</span> <span class="tm-vr">b</span> = <span class="tm-mth">firstElement2</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>]);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20firstElement1%3CT%3E(arr%3A%20T%5B%5D)%20%7B%0A%20%20return%20arr%5B0%5D%3B%0A%7D%0A%0Afunction%20firstElement2%3CT%20extends%20any%5B%5D%3E(arr%3A%20T)%20%7B%0A%20%20return%20arr%5B0%5D%3B%0A%7D%0A%0A%2F%2F%20a%3A%20number%20(good)%0Aconst%20a%20%3D%20firstElement1(%5B1%2C%202%2C%203%5D)%3B%0A%2F%2F%20b%3A%20any%20(bad)%0Aconst%20b%20%3D%20firstElement2(%5B1%2C%202%2C%203%5D)%3B">Try</a></pre></p>
<p>These might seem identical at first glance, but <code>firstElement1</code> is a much better way to write this function.
Its inferred return type is <code>T</code>, but <code>firstElement2</code>'s inferred return type is <code>any</code> because TypeScript has to resolve the <code>arr[0]</code> expression using the constraint type, rather than "waiting" to resolve the element during a call.</p>
<blockquote>
  <p><strong>Rule</strong>: When possible, use the type parameter itself rather than constraining it</p>
</blockquote>
<h4 id="use-fewer-type-parameters"><a href="#use-fewer-type-parameters">Use Fewer Type Parameters</h4></a>
<p>Here's another pair of similar functions:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">filter1</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[], <span class="tm-mth">func</span>: (<span class="tm-vr">arg</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) <span class="tm-kw">=></span> <span class="tm-typ">boolean</span>):<span class="tm-typ"> <span class="typeParameterName">T</span>[] </span>{
    <span class="tm-kw">return</span> <span class="tm-vr">arr</span>.<span class="tm-mth">filter</span>(<span class="tm-vr">func</span>);
}

<span class="tm-kw">function</span> <span class="tm-mth">filter2</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>, <span class="tm-typ"><span class="typeParameterName">F</span></span> <span class="tm-kw">extends</span> (<span class="tm-vr">arg</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) <span class="tm-kw">=></span> <span class="tm-typ">boolean</span>>(<span class="tm-vr">arr</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>[], <span class="tm-vr">func</span>: <span class="tm-typ"><span class="typeParameterName">F</span></span>):<span class="tm-typ"> <span class="typeParameterName">T</span>[] </span>{
    <span class="tm-kw">return</span> <span class="tm-vr">arr</span>.<span class="tm-mth">filter</span>(<span class="tm-vr">func</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20filter1%3CT%3E(arr%3A%20T%5B%5D%2C%20func%3A%20(arg%3A%20T)%20%3D%3E%20boolean)%3A%20T%5B%5D%20%7B%0A%20%20%20%20return%20arr.filter(func)%3B%0A%7D%0A%0Afunction%20filter2%3CT%2C%20F%20extends%20(arg%3A%20T)%20%3D%3E%20boolean%3E(arr%3A%20T%5B%5D%2C%20func%3A%20F)%3A%20T%5B%5D%20%7B%0A%20%20%20%20return%20arr.filter(func)%3B%0A%7D">Try</a></pre></p>
<p>We've created a type parameter <code>F</code> that <em>doesn't relate two values</em>.
That's always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason.
<code>F</code> doesn't do anything but make the function harder to read and reason about!</p>
<blockquote>
  <p><strong>Rule</strong>: Always use as few type parameters as possible</p>
</blockquote>
<h4 id="type-parameters-should-appear-twice"><a href="#type-parameters-should-appear-twice">Type Parameters Should Appear Twice</h4></a>
<p>Sometimes we forget that function doesn't need to be generic:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span><<span class="tm-typ"><span class="typeParameterName">S</span></span> <span class="tm-kw">extends</span> <span class="tm-typ">string</span>>(<span class="tm-vr">s</span>: <span class="tm-typ"><span class="typeParameterName">S</span></span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-vr">s</span>);
}

<span class="tm-mth">greet</span>(<span class="tm-str">"world"</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet%3CS%20extends%20string%3E(s%3A%20S)%20%7B%0A%20%20console.log(%22Hello%2C%20%22%20%2B%20s)%3B%0A%7D%0A%0Agreet(%22world%22)%3B">Try</a></pre></p>
<p>We could just as easily have written a simpler version:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-vr">s</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20greet(s%3A%20string)%20%7B%0A%20%20console.log(%22Hello%2C%20%22%20%2B%20s)%3B%0A%7D">Try</a></pre></p>
<p>Remember, type parameters are for <em>relating the types of multiple values</em>.
If a type parameter is only used once in the function signature, it's not relating anything.</p>
<blockquote>
  <p><strong>Rule</strong>: If a type parameter only appears in one location, strongly reconsider if you actually need it</p>
</blockquote>
<h2 id="optional-parameters"><a href="#optional-parameters">Optional Parameters</h2></a>
<p>Functions in JavaScript often take a variable number of arguments.
For example, the <code>toFixed</code> method of <code>number</code> takes an optional digit count:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f</span>(<span class="tm-vr">n</span>: <span class="tm-typ">number</span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">n</span>.<span class="tm-mth">toFixed</span>()); <span class="tm-cmt">// 0 arguments</span>
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">n</span>.<span class="tm-mth">toFixed</span>(<span class="tm-num">3</span>)); <span class="tm-cmt">// 1 argument</span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f(n%3A%20number)%20%7B%0A%20%20console.log(n.toFixed())%3B%20%2F%2F%200%20arguments%0A%20%20console.log(n.toFixed(3))%3B%20%2F%2F%201%20argument%0A%7D">Try</a></pre></p>
<p>We can model this in TypeScript by marking the parameter as <em>optional</em> with <code>?</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f</span>(<span class="tm-vr">x</span>?: <span class="tm-typ">number</span>) {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-mth">f</span>(); <span class="tm-cmt">// OK</span>
<span class="tm-mth">f</span>(<span class="tm-num">10</span>); <span class="tm-cmt">// OK</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f(x%3F%3A%20number)%20%7B%0A%20%20%2F%2F%20...%0A%7D%0Af()%3B%20%2F%2F%20OK%0Af(10)%3B%20%2F%2F%20OK">Try</a></pre></p>
<p>Although the parameter is specified as type <code>number</code>, the <code>x</code> parameter will actually have the type <code>number | undefined</code> because unspecified parameters in JavaScript get the value <code>undefined</code>.</p>
<p>You can also provide a parameter <em>default</em>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f</span>(<span class="tm-vr">x</span> = <span class="tm-num">10</span>) {
  <span class="tm-cmt">// ...</span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f(x%20%3D%2010)%20%7B%0A%20%20%2F%2F%20...%0A%7D">Try</a></pre></p>
<p>Now in the body of <code>f</code>, <code>x</code> will have type <code>number</code> because any <code>undefined</code> argument will be replaced with <code>10</code>.
Note that when a parameter is optional, callers can always pass <code>undefined</code>, as this simply simualtes a "missing" argument:</p>
<p><pre class="typescript-code"><span class="tm-kw">declare</span> <span class="tm-kw">function</span> <span class="tm-mth">f</span>(<span class="tm-vr">x</span>?: <span class="tm-typ">number</span>):<span class="tm-typ"> void</span>;
<span class="tm-cmt">// cut</span>
<span class="tm-cmt">// All OK</span>
<span class="tm-mth">f</span>();
<span class="tm-mth">f</span>(<span class="tm-num">10</span>);
<span class="tm-mth">f</span>(<span class="tm-kw">undefined</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20f(x%3F%3A%20number)%3A%20void%3B%0A%2F%2F%20cut%0A%2F%2F%20All%20OK%0Af()%3B%0Af(10)%3B%0Af(undefined)%3B">Try</a></pre></p>
<h3 id="optional-parameters-in-callbacks"><a href="#optional-parameters-in-callbacks">Optional Parameters in Callbacks</h3></a>
<p>Once you've learned about optional parameters and function type expressions, it's very easy to make the following mistakes when writing functions that invoke callbacks:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">myForEach</span>(<span class="tm-vr">arr</span>: <span class="tm-typ">any</span>[], <span class="tm-mth">callback</span>: (<span class="tm-vr">arg</span>: <span class="tm-typ">any</span>, <span class="tm-vr">index</span>?: <span class="tm-typ">number</span>) <span class="tm-kw">=></span> <span class="tm-typ">void</span>) {
  <span class="tm-kw">for</span> (<span class="tm-kw">let</span> <span class="tm-vr">i</span> = <span class="tm-num">0</span>; <span class="tm-vr">i</span> < <span class="tm-vr">arr</span>.<span class="tm-vr">length</span>; <span class="tm-vr">i</span>++) {
    <span class="tm-mth">callback</span>(<span class="tm-vr">arr</span>[<span class="tm-vr">i</span>], <span class="tm-vr">i</span>);
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20myForEach(arr%3A%20any%5B%5D%2C%20callback%3A%20(arg%3A%20any%2C%20index%3F%3A%20number)%20%3D%3E%20void)%20%7B%0A%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%0A%20%20%20%20callback(arr%5Bi%5D%2C%20i)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>What people usually <em>intend</em> when writing <code>index?</code> as an optional parameter is that they want both of these calls to be legal:</p>
<p><pre class="typescript-code">
myForEach([1, 2, 3], <span class="tm-vr">a</span> => <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span>));
<span class="tm-mth">myForEach</span>([<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>], (<span class="tm-vr">a</span>, <span class="tm-vr">i</span>) <span class="tm-kw">=></span> <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span>, <span class="tm-vr">i</span>));</pre></p>
<p>What this <em>actually</em> means is that <em><code>callback</code> might get invoked with one argument</em>.
In other words, the function definition says that the implementation might look like this:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">myForEach</span>(<span class="tm-vr">arr</span>: <span class="tm-typ">any</span>[], <span class="tm-mth">callback</span>: (<span class="tm-vr">arg</span>: <span class="tm-typ">any</span>, <span class="tm-vr">index</span>?: <span class="tm-typ">number</span>) <span class="tm-kw">=></span> <span class="tm-typ">void</span>) {
  <span class="tm-kw">for</span> (<span class="tm-kw">let</span> <span class="tm-vr">i</span> = <span class="tm-num">0</span>; <span class="tm-vr">i</span> < <span class="tm-vr">arr</span>.<span class="tm-vr">length</span>; <span class="tm-vr">i</span>++) {
    <span class="tm-cmt">// I don't feel like providing the index today</span>
    <span class="tm-mth">callback</span>(<span class="tm-vr">arr</span>[<span class="tm-vr">i</span>]);
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20myForEach(arr%3A%20any%5B%5D%2C%20callback%3A%20(arg%3A%20any%2C%20index%3F%3A%20number)%20%3D%3E%20void)%20%7B%0A%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20arr.length%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%2F%2F%20I%20don't%20feel%20like%20providing%20the%20index%20today%0A%20%20%20%20callback(arr%5Bi%5D)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>In turn, TypeScript will enforce this meaning and issue errors that aren't really possible:</p>
<p><pre class="typescript-code">
myForEach([1, 2, 3], (<span class="tm-vr">a</span>, <span class="tm-vr">i</span>) => {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2532-144-1"><span class="error-highlight"></span><span class="tm-vr">i</span><span id="errLabel-2532-144-1" role="tooltip" class="error-tooltip">Object is possibly 'undefined'.</span></span>.<span class="tm-mth">toFixed</span>());
});<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is possibly 'undefined'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20myForEach(arr%3A%20any%5B%5D%2C%20callback%3A%20(arg%3A%20any%2C%20index%3F%3A%20number)%20%3D%3E%20void)%3A%20void%0A%2F%2Fcut%0AmyForEach(%5B1%2C%202%2C%203%5D%2C%20(a%2C%20i)%20%3D%3E%20%7B%0A%20%20console.log(i.toFixed())%3B%0A%7D)%3B">Try</a></pre></p>
<p>In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored.
TypeScript behaves the same way.
Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.</p>
<blockquote>
  <p>When writing a function type for a callback, <em>never</em> write an optional parameter unless you intend to <em>call</em> the function without passing that argument</p>
</blockquote>
<h2 id="function-overloads"><a href="#function-overloads">Function Overloads</h2></a>
<p>Some JavaScript functions can be called in a variety of argument counts and types.
For example, you might write a function to produce a <code>Date</code> that takes either a timestamp (one argument) or a month/day/year specification (three arguments).</p>
<p>In TypeScript, we can specify a function that can be called in different ways by writing <em>overload signatures</em>.
To do this, write some number of function signatures (usually two or more), followed by the body of the function:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">makeDate</span>(<span class="tm-vr">timestamp</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">Date</span></span>;
<span class="tm-kw">function</span> <span class="tm-mth">makeDate</span>(<span class="tm-vr">m</span>: <span class="tm-typ">number</span>, <span class="tm-vr">d</span>: <span class="tm-typ">number</span>, <span class="tm-vr">y</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">Date</span></span>;
<span class="tm-kw">function</span> <span class="tm-mth">makeDate</span>(<span class="tm-vr">mOrTimestamp</span>: <span class="tm-typ">number</span>, <span class="tm-vr">d</span>?: <span class="tm-typ">number</span>, <span class="tm-vr">y</span>?: <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">Date</span> </span>{
  <span class="tm-kw">if</span> (<span class="tm-vr">d</span> !== <span class="tm-kw">undefined</span> && <span class="tm-vr">y</span> !== <span class="tm-kw">undefined</span>) {
    <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Date</span>(<span class="tm-vr">y</span>, <span class="tm-vr">mOrTimestamp</span>, <span class="tm-vr">d</span>);
  } <span class="tm-kw">else</span> {
    <span class="tm-kw">return</span> <span class="tm-kw">new</span> <span class="tm-typ">Date</span>(<span class="tm-vr">mOrTimestamp</span>);
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">d1</span> = <span class="tm-mth">makeDate</span>(<span class="tm-num">12345678</span>);
<span class="tm-kw">const</span> <span class="tm-vr">d2</span> = <span class="tm-mth">makeDate</span>(<span class="tm-num">5</span>, <span class="tm-num">5</span>, <span class="tm-num">5</span>);
<span class="tm-kw">const</span> <span class="tm-vr">d3</span> = <span class="error" tabindex="0" aria-describedby="errLabel-2575-383-14"><span class="error-highlight"></span><span class="tm-mth">makeDate</span>(<span class="tm-num">1</span>, <span class="tm-num">3</span>)<span id="errLabel-2575-383-14" role="tooltip" class="error-tooltip">No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20makeDate(timestamp%3A%20number)%3A%20Date%3B%0Afunction%20makeDate(m%3A%20number%2C%20d%3A%20number%2C%20y%3A%20number)%3A%20Date%3B%0Afunction%20makeDate(mOrTimestamp%3A%20number%2C%20d%3F%3A%20number%2C%20y%3F%3A%20number)%3A%20Date%20%7B%0A%20%20if%20(d%20!%3D%3D%20undefined%20%26%26%20y%20!%3D%3D%20undefined)%20%7B%0A%20%20%20%20return%20new%20Date(y%2C%20mOrTimestamp%2C%20d)%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20new%20Date(mOrTimestamp)%3B%0A%20%20%7D%0A%7D%0Aconst%20d1%20%3D%20makeDate(12345678)%3B%0Aconst%20d2%20%3D%20makeDate(5%2C%205%2C%205)%3B%0Aconst%20d3%20%3D%20makeDate(1%2C%203)%3B">Try</a></pre></p>
<p>In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments.
These first two signatures are called the <em>overload signatures</em>.</p>
<p>Then, we wrote a function implementation with a compatible signature.
Functions have an <em>implementation</em> signature, but this signature can't be called directly.
Even though we wrote a function with two optional parameters after the required one, it can't be called with two parameters!</p>
<h3 id="overload-signatures-and-the-implementation-signature"><a href="#overload-signatures-and-the-implementation-signature">Overload Signatures and the Implementation Signature</h3></a>
<p>This is a common source of confusion.
Often people will write code like this and not understand why there is an error:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> void</span>;
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>() {
  <span class="tm-cmt">// ...</span>
}
<span class="tm-cmt">// Expected to be able to call with zero arguments</span>
<span class="error" tabindex="0" aria-describedby="errLabel-2554-108-4"><span class="error-highlight"></span><span class="tm-mth">fn</span>()<span id="errLabel-2554-108-4" role="tooltip" class="error-tooltip">Expected 1 arguments, but got 0.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Expected 1 arguments, but got 0.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fn(x%3A%20string)%3A%20void%3B%0Afunction%20fn()%20%7B%0A%20%20%2F%2F%20...%0A%7D%0A%2F%2F%20Expected%20to%20be%20able%20to%20call%20with%20zero%20arguments%0Afn()%3B">Try</a></pre></p>
<p>Again, the signature used to write the function body can't be "seen" from the outside.</p>
<blockquote>
  <p>The signature of the <em>implementation</em> is not visible from the outside.
  When writing an overloaded function, you should always have <em>two</em> or more signatures above the implementation of the function.</p>
</blockquote>
<p>The implementation signature must also be <em>compatible</em> with the overload signatures.
For example, these functions have errors because the implementation signature doesn't match the overloads in a correct way:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">boolean</span>):<span class="tm-typ"> void</span>;
<span class="tm-cmt">// Argument type isn't right</span>
<span class="tm-kw">function</span> <span class="error" tabindex="0" aria-describedby="errLabel-2394-69-2"><span class="error-highlight"></span><span class="tm-mth">fn</span><span id="errLabel-2394-69-2" role="tooltip" class="error-tooltip">This overload signature is not compatible with its implementation signature.</span></span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> void</span>;
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">boolean</span>) {

}<hr class="error-divider"><div class="listed-error"><div class="error-line">This overload signature is not compatible with its implementation signature.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fn(x%3A%20boolean)%3A%20void%3B%0A%2F%2F%20Argument%20type%20isn't%20right%0Afunction%20fn(x%3A%20string)%3A%20void%3B%0Afunction%20fn(x%3A%20boolean)%20%7B%0A%0A%7D">Try</a></pre></p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> string</span>;
<span class="tm-cmt">// Return type isn't right</span>
<span class="tm-kw">function</span> <span class="error" tabindex="0" aria-describedby="errLabel-2394-68-2"><span class="error-highlight"></span><span class="tm-mth">fn</span><span id="errLabel-2394-68-2" role="tooltip" class="error-tooltip">This overload signature is not compatible with its implementation signature.</span></span>(<span class="tm-vr">x</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> boolean</span>;
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span>) {
  <span class="tm-kw">return</span> <span class="tm-str">"oops"</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">This overload signature is not compatible with its implementation signature.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fn(x%3A%20string)%3A%20string%3B%0A%2F%2F%20Return%20type%20isn't%20right%0Afunction%20fn(x%3A%20number)%3A%20boolean%3B%0Afunction%20fn(x%3A%20string%20%7C%20number)%20%7B%0A%20%20return%20%22oops%22%3B%0A%7D">Try</a></pre></p>
<h3 id="writing-good-overloads"><a href="#writing-good-overloads">Writing Good Overloads</h3></a>
<p>Like generics, there are a few guidelines you should follow when using function overloads.
Following these principles will make your function easier to call, easier to understand, and easier to implement.</p>
<p>Let's consider a function that returns the length of a string or an array:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">len</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> number</span>;
<span class="tm-kw">function</span> <span class="tm-mth">len</span>(<span class="tm-vr">arr</span>: <span class="tm-typ">any</span>[]):<span class="tm-typ"> number</span>;
<span class="tm-kw">function</span> <span class="tm-mth">len</span>(<span class="tm-vr">x</span>: <span class="tm-typ">any</span>) {
  <span class="tm-kw">return</span> <span class="tm-vr">x</span>.<span class="tm-vr">length</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20len(s%3A%20string)%3A%20number%3B%0Afunction%20len(arr%3A%20any%5B%5D)%3A%20number%3B%0Afunction%20len(x%3A%20any)%20%7B%0A%20%20return%20x.length%3B%0A%7D">Try</a></pre></p>
<p>This function is fine; we can invoke it with strings or arrays.
However, we can't invoke it with a value that might be a string <em>or</em> an array, because TypeScript can only resolve a function call to a single overload:</p>
<p><pre class="typescript-code">
<span class="tm-mth">len</span>(<span class="tm-str">""</span>); <span class="tm-cmt">// OK</span>
<span class="tm-mth">len</span>([<span class="tm-num">0</span>]); <span class="tm-cmt">// OK</span>
<span class="tm-mth">len</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-124-35"><span class="error-highlight"></span><span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() > <span class="tm-num">0.5</span> ? <span class="tm-str">"hello"</span> : [<span class="tm-num">0</span>]<span id="errLabel-2345-124-35" role="tooltip" class="error-tooltip">Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
  Type '"hello"' is not assignable to type 'any[]'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.</div><div class="error-line"><div class="indent"></div>Type '"hello"' is not assignable to type 'any[]'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20function%20len(s%3A%20string)%3A%20number%3B%0Adeclare%20function%20len(arr%3A%20any%5B%5D)%3A%20number%3B%0A%2F%2Fcut%0Alen(%22%22)%3B%20%2F%2F%20OK%0Alen(%5B0%5D)%3B%20%2F%2F%20OK%0Alen(Math.random()%20%3E%200.5%20%3F%20%22hello%22%20%3A%20%5B0%5D)%3B">Try</a></pre></p>
<p>Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">len</span>(<span class="tm-vr">x</span>: <span class="tm-typ">any</span>[] | <span class="tm-typ">string</span>) {
  <span class="tm-kw">return</span> <span class="tm-vr">x</span>.<span class="tm-vr">length</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20len(x%3A%20any%5B%5D%20%7C%20string)%20%7B%0A%20%20return%20x.length%3B%0A%7D">Try</a></pre></p>
<p>This is much better!
Callers can invoke this with either sort of value, and as an added bonus, we don't have to figure out a correct implementation signature.</p>
<blockquote>
  <p>Always prefer parameters with union types instead of overloads when possible</p>
</blockquote>
<h2 id="other-types-to-know-about"><a href="#other-types-to-know-about">Other Types to Know About</h2></a>
<p>There are some additional types you'll want to recognize that appear often when working with function types.
Like all types, you can use them everywhere, but these are especially relevant in the context of functions.</p>
<h3 id="void"><a href="#void"><code>void</code></h3></a>
<p><code>void</code> represents the return value of functions which don't return a value.
It's the inferred type any time a function doesn't have any <code>return</code> statements, or doesn't return any explicit value from those return statements:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// The inferred return type is void</span>
<span class="tm-kw">function</span> <span class="tm-mth">noop</span>() {
  <span class="tm-kw">return</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20The%20inferred%20return%20type%20is%20void%0Afunction%20noop()%20%7B%0A%20%20return%3B%0A%7D">Try</a></pre></p>
<p>In JavaScript, a function that doesn't return any value will implicitly return the value <code>undefined</code>.
However, <code>void</code> and <code>undefined</code> are not the same thing in TypeScript.
See the reference page Why void is a special type for a longer discussion about this.</p>
<blockquote>
  <p><code>void</code> is not the same as <code>undefined</code>.</p>
</blockquote>
<h3 id="object"><a href="#object"><code>object</code></h3></a>
<p>The special type <code>object</code> refers to any value that isn't a primitive (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, or <code>undefined</code>).
This is different from the <em>empty object type</em> <code>{ }</code>, and also different from the global type <code>Object</code>.
You can read the reference page about The global types for information on what <code>Object</code> is for - long story short, don't ever use <code>Object</code>.</p>
<blockquote>
  <p><code>object</code> is not <code>Object</code>. <strong>Always</strong> use <code>object</code>!</p>
</blockquote>
<p>Note that in JavaScript, function values are objects: They have properties, have <code>Object.prototype</code> in their prototype chain, are <code>instanceof Object</code>, you can call <code>Object.keys</code> on them, and so on.
For this reason, function types are considered to be <code>object</code>s in TypeScript.</p>
<h3 id="unknown"><a href="#unknown"><code>unknown</code></h3></a>
<p>The <code>unknown</code> type represents <em>any</em> value.
This is similar to the <code>any</code> type, but is safer because it's not legal to do anything with an <code>unknown</code> value:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f1</span>(<span class="tm-vr">a</span>: <span class="tm-typ">any</span>) {
  <span class="tm-vr">a</span>.<span class="tm-mth">b</span>(); <span class="tm-cmt">// OK</span>
}
<span class="tm-kw">function</span> <span class="tm-mth">f2</span>(<span class="tm-vr">a</span>: <span class="tm-typ">unknown</span>) {
  <span class="error" tabindex="0" aria-describedby="errLabel-2571-67-1"><span class="error-highlight"></span><span class="tm-vr">a</span><span id="errLabel-2571-67-1" role="tooltip" class="error-tooltip">Object is of type 'unknown'.</span></span>.<span class="tm-mth">b</span>();
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Object is of type 'unknown'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f1(a%3A%20any)%20%7B%0A%20%20a.b()%3B%20%2F%2F%20OK%0A%7D%0Afunction%20f2(a%3A%20unknown)%20%7B%0A%20%20a.b()%3B%0A%7D">Try</a></pre></p>
<p>This is useful when describing function types because you can describe functions that accept any value without having <code>any</code> values in your function body.</p>
<p>Conversely, you can describe a function that returns a value of unknown type:</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">safeParse</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> unknown </span>{
  <span class="tm-kw">return</span> <span class="tm-typ">JSON</span>.<span class="tm-mth">parse</span>(<span class="tm-vr">s</span>);
}

<span class="tm-cmt">// Need to be careful with 'obj'!</span>
<span class="tm-kw">const</span> <span class="tm-vr">obj</span> = <span class="tm-mth">safeParse</span>(<span class="tm-vr">someRandomString</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20const%20someRandomString%3A%20string%3B%0A%2F%2Fcut%0Afunction%20safeParse(s%3A%20string)%3A%20unknown%20%7B%0A%20%20return%20JSON.parse(s)%3B%0A%7D%0A%0A%2F%2F%20Need%20to%20be%20careful%20with%20'obj'!%0Aconst%20obj%20%3D%20safeParse(someRandomString)%3B">Try</a></pre></p>
<h3 id="never"><a href="#never"><code>never</code></h3></a>
<p>Some functions <em>never</em> return a value:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fail</span>(<span class="tm-vr">msg</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> never </span>{
  <span class="tm-kw">throw</span> <span class="tm-kw">new</span> <span class="tm-typ">Error</span>(<span class="tm-vr">msg</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fail(msg%3A%20string)%3A%20never%20%7B%0A%20%20throw%20new%20Error(msg)%3B%0A%7D">Try</a></pre></p>
<p>The <code>never</code> type represents values which are <em>never</em> observed.
In a return type, this means that the function throws an exception or terminates execution of the program.</p>
<p><code>never</code> also appears when TypeScript determines there's nothing left in a union.</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span>) {
  <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">x</span> === <span class="tm-str">"string"</span>) {
    <span class="tm-cmt">// do something</span>
  } <span class="tm-kw">else</span> <span class="tm-kw">if</span> (<span class="tm-kw">typeof</span> <span class="tm-vr">x</span> === <span class="tm-str">"number"</span>) {
    <span class="tm-cmt">// do something else</span>
  } <span class="tm-kw">else</span> {
    <span class="tm-vr">x</span>; <span class="tm-cmt">// has type 'never'!</span>
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20fn(x%3A%20string%20%7C%20number)%20%7B%0A%20%20if%20(typeof%20x%20%3D%3D%3D%20%22string%22)%20%7B%0A%20%20%20%20%2F%2F%20do%20something%0A%20%20%7D%20else%20if%20(typeof%20x%20%3D%3D%3D%20%22number%22)%20%7B%0A%20%20%20%20%2F%2F%20do%20something%20else%0A%20%20%7D%20else%20%7B%0A%20%20%20%20x%3B%20%2F%2F%20has%20type%20'never'!%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h3 id="the-global-function-type"><a href="#the-global-function-type"><code>Function</code></h3></a>
<p>The global type <code>Function</code> describes properties like <code>bind</code>, <code>call</code>, <code>apply</code>, and others present on all function values in JavaScript.
It also has the special property that values of type <code>Function</code> can always be called; these calls return <code>any</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">doSomething</span>(<span class="tm-vr">f</span>: <span class="tm-typ"><span class="interfaceName">Function</span></span>) {
  <span class="tm-mth">f</span>(<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20doSomething(f%3A%20Function)%20%7B%0A%20%20f(1%2C%202%2C%203)%3B%0A%7D">Try</a></pre></p>
<p>This is an <em>untyped function call</em> and is generally best avoided because of the unsafe <code>any</code> return type.</p>
<p>If need to accept an arbitrary function but don't intend to call it, the type <code>() =&gt; void</code> is generally safer.</p>
<h2 id="rest-parameters-and-arguments"><a href="#rest-parameters-and-arguments">Rest Parameters and Arguments</h2></a>
<p><strong>Background reading</strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">Rest Parameters</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread Syntax</a></p>
<h3 id="rest-parameters"><a href="#rest-parameters">Rest Parameters</h3></a>
<p>In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an <em>unbounded</em> number of arguments using <em>rest parameters</em>.</p>
<p>A rest parameter appears after all other parameters, and uses the <code>...</code> syntax:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">multiply</span>(<span class="tm-vr">n</span>: <span class="tm-typ">number</span>, ...<span class="tm-vr">m</span>: <span class="tm-typ">number</span>[]) {
  <span class="tm-kw">return</span> <span class="tm-vr">m</span>.<span class="tm-mth">map</span>(<span class="tm-vr">x</span> <span class="tm-kw">=></span> <span class="tm-vr">n</span> * <span class="tm-vr">x</span>);
}
<span class="tm-cmt">// 'a' gets value [10, 20, 30, 40]</span>
<span class="tm-kw">const</span> <span class="tm-vr">a</span> = <span class="tm-mth">multiply</span>(<span class="tm-num">10</span>, <span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>, <span class="tm-num">4</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20multiply(n%3A%20number%2C%20...m%3A%20number%5B%5D)%20%7B%0A%20%20return%20m.map(x%20%3D%3E%20n%20*%20x)%3B%0A%7D%0A%2F%2F%20'a'%20gets%20value%20%5B10%2C%2020%2C%2030%2C%2040%5D%0Aconst%20a%20%3D%20multiply(10%2C%201%2C%202%2C%203%2C%204)%3B">Try</a></pre></p>
<p>In TypeScript, the type annotation on these parameters is implicitly <code>any[]</code> instead of <code>any</code>, and any type annotation given must be of the form <code>Array&lt;T&gt;</code>or <code>T[]</code>, or a tuple type (which we'll learn about later).</p>
<h3 id="rest-arguments"><a href="#rest-arguments">Rest Arguments</h3></a>
<p>Conversely, we can <em>provide</em> a variable number of arguments from an array using the spread syntax.
For example, the <code>push</code> method of arrays takes any number of arguments:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">arr1</span> = [<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>];
<span class="tm-kw">const</span> <span class="tm-vr">arr2</span> = [<span class="tm-num">4</span>, <span class="tm-num">5</span>, <span class="tm-num">6</span>];
<span class="tm-vr">arr1</span>.<span class="tm-mth">push</span>(...<span class="tm-vr">arr2</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=const%20arr1%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Aconst%20arr2%20%3D%20%5B4%2C%205%2C%206%5D%3B%0Aarr1.push(...arr2)%3B">Try</a></pre></p>
<p>Note that in general, TypeScript does not assume that arrays are immutable.
This can lead to some surprising behavior:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Inferred type is number[] -- "an array with zero or more numbers",</span>
<span class="tm-cmt">// not specfically two numbers</span>
<span class="tm-kw">const</span> <span class="tm-vr">args</span> = [<span class="tm-num">8</span>, <span class="tm-num">5</span>];
<span class="tm-kw">const</span> <span class="tm-vr">angle</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">atan2</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2556-147-7"><span class="error-highlight"></span>...<span class="tm-vr">args</span><span id="errLabel-2556-147-7" role="tooltip" class="error-tooltip">Expected 2 arguments, but got 0 or more.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Expected 2 arguments, but got 0 or more.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Inferred%20type%20is%20number%5B%5D%20--%20%22an%20array%20with%20zero%20or%20more%20numbers%22%2C%0A%2F%2F%20not%20specfically%20two%20numbers%0Aconst%20args%20%3D%20%5B8%2C%205%5D%3B%0Aconst%20angle%20%3D%20Math.atan2(...args)%3B">Try</a></pre></p>
<p>The best fix for this situation depends a bit on your code, but in general a <code>const</code> context is the most straightforward solution:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Inferred as 2-length tuple</span>
<span class="tm-kw">const</span> <span class="tm-vr">args</span> = [<span class="tm-num">8</span>, <span class="tm-num">5</span>] <span class="tm-kw">as</span> <span class="tm-typ">const</span>;
<span class="tm-cmt">// OK</span>
<span class="tm-kw">const</span> <span class="tm-vr">angle</span> = <span class="tm-typ">Math</span>.<span class="tm-mth">atan2</span>(...<span class="tm-vr">args</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Inferred%20as%202-length%20tuple%0Aconst%20args%20%3D%20%5B8%2C%205%5D%20as%20const%3B%0A%2F%2F%20OK%0Aconst%20angle%20%3D%20Math.atan2(...args)%3B">Try</a></pre></p>
<!-- TODO link to downlevel iteration -->
<h2 id="parameter-destructuring"><a href="#parameter-destructuring">Parameter Destructuring</h2></a>
<aside>
    <p><strong>Background reading</strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring Assignment</a></p>
  </aside>
<p>You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body.
In JavaScript, it looks like this:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">sum</span>({ <span class="tm-vr">a</span>, <span class="tm-vr">b</span>, <span class="tm-vr">c</span> }) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span> + <span class="tm-vr">b</span> + <span class="tm-vr">c</span>);
}
<span class="tm-mth">sum</span>({ <span class="tm-vr">a:</span> <span class="tm-num">10</span>, <span class="tm-vr">b:</span> <span class="tm-num">3</span>, <span class="tm-vr">c:</span> <span class="tm-num">9</span> });<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20sum(%7B%20a%2C%20b%2C%20c%20%7D)%20%7B%0A%20%20console.log(a%20%2B%20b%20%2B%20c)%3B%0A%7D%0Asum(%7B%20a%3A%2010%2C%20b%3A%203%2C%20c%3A%209%20%7D)%3B">Try</a></pre></p>
<p>The type annotation for the object goes after the destructuring syntax:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">sum</span>({ <span class="tm-vr">a</span>, <span class="tm-vr">b</span>, <span class="tm-vr">c</span> }: { <span class="tm-vr">a</span>: <span class="tm-typ">number</span>, <span class="tm-vr">b</span>: <span class="tm-typ">number</span>, <span class="tm-vr">c</span>: <span class="tm-typ">number</span> }) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span> + <span class="tm-vr">b</span> + <span class="tm-vr">c</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20sum(%7B%20a%2C%20b%2C%20c%20%7D%3A%20%7B%20a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20number%20%7D)%20%7B%0A%20%20console.log(a%20%2B%20b%20%2B%20c)%3B%0A%7D">Try</a></pre></p>
<p>This can look a bit verbose, but you can use a named type here as well:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Same as prior example</span>
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">ABC</span></span> = { <span class="tm-vr">a</span>: <span class="tm-typ">number</span>, <span class="tm-vr">b</span>: <span class="tm-typ">number</span>, <span class="tm-vr">c</span>: <span class="tm-typ">number</span> };
<span class="tm-kw">function</span> <span class="tm-mth">sum</span>({ <span class="tm-vr">a</span>, <span class="tm-vr">b</span>, <span class="tm-vr">c</span> }: <span class="tm-typ"><span class="typeAliasName">ABC</span></span>) {
  <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span> + <span class="tm-vr">b</span> + <span class="tm-vr">c</span>);
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Same%20as%20prior%20example%0Atype%20ABC%20%3D%20%7B%20a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20number%20%7D%3B%0Afunction%20sum(%7B%20a%2C%20b%2C%20c%20%7D%3A%20ABC)%20%7B%0A%20%20console.log(a%20%2B%20b%20%2B%20c)%3B%0A%7D">Try</a></pre></p>
<h2 id="assignability-of-functions"><a href="#assignability-of-functions">Assignability of Functions</h2></a><hr><h1 id="types-from-extraction"><a href="#types-from-extraction">Types from Extraction</h1></a>
<p>TypeScript's type system is very powerful because it allows expressing types <em>in terms of other types</em>.
Although the simplest form of this is generics, we actually have a wide variety of <em>type operators</em> available to us.
It's also possible to express types in terms of <em>values</em> that we already have.</p>
<p>By combining various type operators, we can express complex operations and values in a succinct, maintainable way.
In this chapter we'll cover ways to express a type in terms of an existing type or value.</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#typeof">The <code>typeof</code> type operator </a></li><ul><li><a href="#limitations">Limitations</a></li></ul><li><a href="#keyof">The <code>keyof</code> type operator</a></li><li><a href="#indexed-access-types">Indexed Access Types</a></li></ul></ul></div>
<h2 id="typeof"><a href="#typeof">The <code>typeof</code> type operator </h2></a>
<p>JavaScript already has a <code>typeof</code> operator you can use in an <em>expression</em> context:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Prints "string"</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-kw">typeof</span> <span class="tm-str">"Hello world"</span>);</pre></p>
<p>TypeScript adds a <code>typeof</code> operator you can use in a <em>type</em> context to refer to the <em>type</em> of a variable or property:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">s</span> = <span class="tm-str">"hello"</span>;
<span class="tm-kw">let</span> <span class="tm-vr">n</span>: <span class="tm-kw">typeof</span> <span class="tm-typ">s</span>;
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">n</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span></span></pre></p>
<p>This isn't very useful for basic types, but combined with other type operators, you can use <code>typeof</code> to conveniently express many patterns.
For an example, let's start by looking at the predefined type <code>ReturnType&lt;T&gt;</code>.
It takes a <em>function type</em> and produces its return type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Predicate</span></span> = (<span class="tm-vr">x</span>: <span class="tm-typ">unknown</span>) <span class="tm-kw">=></span> <span class="tm-typ">boolean</span>;
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">K</span></span> = <span class="tm-typ"><span class="typeAliasName">ReturnType</span></span><<span class="tm-typ"><span class="typeAliasName">Predicate</span></span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">K</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">boolean</span></span></pre></p>
<p>If we try to use <code>ReturnType</code> on a function name, we see an instructive error:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f</span>() {
    <span class="tm-kw">return</span> { <span class="tm-vr">x:</span> <span class="tm-num">10</span>, <span class="tm-vr">y:</span> <span class="tm-num">3</span> };
}
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">P</span></span> = <span class="tm-typ"><span class="typeAliasName">ReturnType</span></span><<span class="error" tabindex="0" aria-describedby="errLabel-2749-65-1"><span class="error-highlight"></span><span class="tm-typ">f</span><span id="errLabel-2749-65-1" role="tooltip" class="error-tooltip">'f' refers to a value, but is being used as a type here.</span></span>>;<hr class="error-divider"><div class="listed-error"><div class="error-line">'f' refers to a value, but is being used as a type here.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f()%20%7B%0A%20%20%20%20return%20%7B%20x%3A%2010%2C%20y%3A%203%20%7D%3B%0A%7D%0Atype%20P%20%3D%20ReturnType%3Cf%3E%3B">Try</a></pre></p>
<p>Remember that <em>values</em> and <em>types</em> aren't the same thing.
To refer to the <em>type</em> that the <em>value <code>f</code></em> has, we use <code>typeof</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">function</span> <span class="tm-mth">f</span>() {
    <span class="tm-kw">return</span> { <span class="tm-vr">x:</span> <span class="tm-num">10</span>, <span class="tm-vr">y:</span> <span class="tm-num">3</span> };
}
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">P</span></span> = <span class="tm-typ"><span class="typeAliasName">ReturnType</span></span><<span class="tm-kw">typeof</span> <span class="tm-typ">f</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">P</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="punctuation">{</span><span class="lineBreak">
</span><span class="space">    </span><span class="propertyName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span><span class="punctuation">;</span><span class="lineBreak">
</span><span class="space">    </span><span class="propertyName">y</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span><span class="punctuation">;</span><span class="lineBreak">
</span><span class="punctuation">}</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=function%20f()%20%7B%0A%20%20%20%20return%20%7B%20x%3A%2010%2C%20y%3A%203%20%7D%3B%0A%7D%0Atype%20P%20%3D%20ReturnType%3Ctypeof%20f%3E%3B">Try</a></pre></p>
<h3 id="limitations"><a href="#limitations">Limitations</h3></a>
<p>TypeScript intentionally limits the sorts of expressions you can use <code>typeof</code> on.
Specifically, it's only legal to use <code>typeof</code> on identifiers (i.e. variable names) or their properties.
This helps avoid the confusing trap of writing code you think is executing, but isn't:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// Meant to use =</span>
<span class="tm-kw">let</span> <span class="tm-vr">x</span> : <span class="tm-typ"><span class="typeAliasName">msgbox</span></span><span class="error" tabindex="0" aria-describedby="errLabel-1005-84-1"><span class="error-highlight"></span>(<span id="errLabel-1005-84-1" role="tooltip" class="error-tooltip">',' expected.</span></span><span class="tm-str">"Are you sure you want to continue?"</span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">',' expected.</div></div></pre></p>
<h2 id="keyof"><a href="#keyof">The <code>keyof</code> type operator</h2></a>
<p>The <code>keyof</code> operator takes a type and produces a string or numeric literal union of its keys:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Point</span></span> = { <span class="tm-vr">x</span>: <span class="tm-typ">number</span>, <span class="tm-vr">y</span>: <span class="tm-typ">number</span> };
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">P</span></span> = <span class="tm-kw">keyof</span> <span class="tm-typ"><span class="typeAliasName">Point</span></span>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">P</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="stringLiteral">"x"</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="stringLiteral">"y"</span></span></pre></p>
<p>If the type has a <code>string</code> or <code>number</code> index signature, <code>keyof</code> will return those types instead:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Arrayish</span></span> = { [<span class="tm-vr">n</span>: <span class="tm-typ">number</span>]: <span class="tm-typ">unknown</span> };
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">A</span></span> = <span class="tm-kw">keyof</span> <span class="tm-typ"><span class="typeAliasName">Arrayish</span></span>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">A</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">number</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Mapish</span></span> = { [<span class="tm-vr">k</span>: <span class="tm-typ">string</span>]: <span class="tm-typ">boolean</span> };
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">M</span></span> = <span class="tm-kw">keyof</span> <span class="tm-typ"><span class="typeAliasName">Mapish</span></span>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">M</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Arrayish%20%3D%20%7B%20%5Bn%3A%20number%5D%3A%20unknown%20%7D%3B%0Atype%20A%20%3D%20keyof%20Arrayish%3B%0A%0Atype%20Mapish%20%3D%20%7B%20%5Bk%3A%20string%5D%3A%20boolean%20%7D%3B%0Atype%20M%20%3D%20keyof%20Mapish%3B">Try</a></pre></p>
<p>Note that in this example, <code>M</code> is <code>string | number</code> -- this is because JavaScript object keys are always coerced to a string, so <code>obj[0]</code> is always the same as <code>obj["0"]</code>.</p>
<p><code>keyof</code> types become especially useful when combined with mapped types, which we'll learn more about later.</p>
<h2 id="indexed-access-types"><a href="#indexed-access-types">Indexed Access Types</h2></a>
<p>We can use <code>typeof</code> to reference the type of a property of a value.
What if we want to reference the type of a property of a type instead?</p>
<p>We can use an <em>indexed access type</em> to look up a specific property on another type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Person</span></span> = { <span class="tm-vr">age</span>: <span class="tm-typ">number</span>, <span class="tm-vr">name</span>: <span class="tm-typ">string</span>, <span class="tm-vr">alive</span>: <span class="tm-typ">boolean</span> };
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">A</span></span> = <span class="tm-typ"><span class="typeAliasName">Person</span></span>[<span class="tm-str">"age"</span>];
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">A</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">number</span></span></pre></p>
<p>The indexing type is itself a type, so we can use unions, <code>keyof</code>, or other types entirely:</p>
<p><pre class="typescript-code">
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">I1</span></span> = <span class="tm-typ"><span class="typeAliasName">Person</span></span>[<span class="tm-str">"age"</span> | <span class="tm-str">"name"</span>];
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">I1</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">I2</span></span> = <span class="tm-typ"><span class="typeAliasName">Person</span></span>[<span class="tm-kw">keyof</span> <span class="tm-typ"><span class="typeAliasName">Person</span></span>];
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">I2</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">boolean</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">AliveOrName</span></span> = <span class="tm-str">"alive"</span> | <span class="tm-str">"name"</span>;
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">I3</span></span> = <span class="tm-typ"><span class="typeAliasName">Person</span></span>[<span class="tm-typ"><span class="typeAliasName">AliveOrName</span></span>];
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">I3</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">boolean</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Person%20%3D%20%7B%20age%3A%20number%2C%20name%3A%20string%2C%20alive%3A%20boolean%20%7D%3B%0A%2F%2Fcut%0Atype%20I1%20%3D%20Person%5B%22age%22%20%7C%20%22name%22%5D%3B%0A%0Atype%20I2%20%3D%20Person%5Bkeyof%20Person%5D%3B%0A%0Atype%20AliveOrName%20%3D%20%22alive%22%20%7C%20%22name%22%3B%0Atype%20I3%20%3D%20Person%5BAliveOrName%5D%3B">Try</a></pre></p>
<p>You'll even see an error if you try to index a property that doesn't exist:</p>
<p><pre class="typescript-code">
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">I1</span></span> = <span class="tm-typ"><span class="typeAliasName">Person</span></span>[<span class="error" tabindex="0" aria-describedby="errLabel-2339-84-6"><span class="error-highlight"></span><span class="tm-str">"alve"</span><span id="errLabel-2339-84-6" role="tooltip" class="error-tooltip">Property 'alve' does not exist on type 'Person'.</span></span>];<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'alve' does not exist on type 'Person'.</div></div></pre></p>
<p>Another example of indexing with an arbitrary type is using <code>number</code> to get the type of an array's elements.
We can combine this with <code>typeof</code> to conveniently capture the element type of an array literal:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">MyArray</span> = [
    { <span class="tm-vr">name:</span> <span class="tm-str">"Alice"</span>, <span class="tm-vr">age:</span> <span class="tm-num">15</span> },
    { <span class="tm-vr">name:</span> <span class="tm-str">"Bob"</span>, <span class="tm-vr">age:</span> <span class="tm-num">23</span> },
    { <span class="tm-vr">name:</span> <span class="tm-str">"Eve"</span>, <span class="tm-vr">age:</span> <span class="tm-num">38</span> }
];

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">T</span></span> = (<span class="tm-kw">typeof</span> <span class="tm-typ">MyArray</span>)[<span class="tm-typ">number</span>];
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">T</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="punctuation">{</span><span class="lineBreak">
</span><span class="space">    </span><span class="propertyName">name</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="punctuation">;</span><span class="lineBreak">
</span><span class="space">    </span><span class="propertyName">age</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span><span class="punctuation">;</span><span class="lineBreak">
</span><span class="punctuation">}</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=const%20MyArray%20%3D%20%5B%0A%20%20%20%20%7B%20name%3A%20%22Alice%22%2C%20age%3A%2015%20%7D%2C%0A%20%20%20%20%7B%20name%3A%20%22Bob%22%2C%20age%3A%2023%20%7D%2C%0A%20%20%20%20%7B%20name%3A%20%22Eve%22%2C%20age%3A%2038%20%7D%0A%5D%3B%0A%0Atype%20T%20%3D%20(typeof%20MyArray)%5Bnumber%5D%3B">Try</a></pre></p><hr><h1 id="types-from-transformation"><a href="#types-from-transformation">Types from Transformation</h1></a>
<p>There are certain patterns that are very commonplace in JavaScript, like iterating over the keys of objects to create new ones, and returning different values based on the inputs given to us.
This idea of creating new values and types on the fly is somewhat untraditional in typed languages, but TypeScript provides some useful base constructs in the type system to accurately model that behavior, much in the same way that <code>keyof</code> can be used to discuss the property names of objects, and indexed access types can be used to fetch values of a certain property name.</p>
<p>We'll quickly see that combined, these smaller constructs can be surprisingly powerful and can express many patterns in the JavaScript ecosystem.</p>
<h2 id="conditional-types"><a href="#conditional-types">Conditional Types</h2></a>
<p>At the heart of most useful programs, we have to make decisions based on input.
JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs.
<em>Conditional types</em> help describe the relation between the types of inputs and outputs.</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Animal</span></span> {
    <span class="tm-mth">live</span>():<span class="tm-typ"> void</span>;
}
<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Dog</span></span> <span class="tm-kw">extends</span> <span class="interfaceName">Animal</span> {
    <span class="tm-mth">woof</span>():<span class="tm-typ"> void</span>;
}

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Foo</span></span> = <span class="tm-typ"><span class="interfaceName">Dog</span></span> <span class="tm-typ">extends</span> <span class="tm-typ"><span class="interfaceName">Animal</span></span> ? <span class="tm-typ">number</span> : <span class="tm-typ">string</span>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Foo</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">number</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Bar</span></span> = <span class="tm-typ"><span class="interfaceName">RegExp</span></span> <span class="tm-typ">extends</span> <span class="tm-typ"><span class="interfaceName">Animal</span></span> ? <span class="tm-typ">number</span> : <span class="tm-typ">string</span>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Bar</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Animal%20%7B%0A%20%20%20%20live()%3A%20void%3B%0A%7D%0Ainterface%20Dog%20extends%20Animal%20%7B%0A%20%20%20%20woof()%3A%20void%3B%0A%7D%0A%0Atype%20Foo%20%3D%20Dog%20extends%20Animal%20%3F%20number%20%3A%20string%3B%0A%0Atype%20Bar%20%3D%20RegExp%20extends%20Animal%20%3F%20number%20%3A%20string%3B">Try</a></pre></p>
<p>Conditional types take a form that looks a little like conditional expresions (<code>cond ? trueExpression : falseExpression</code>) in JavaScript:</p>
<p><pre class="typescript-code">
<span class="tm-typ"><span class="typeAliasName">SomeType</span></span> <span class="tm-typ">extends</span> <span class="tm-typ"><span class="typeAliasName">OtherType</span></span> ? <span class="tm-typ"><span class="typeAliasName">TrueType</span></span> : <span class="tm-typ"><span class="typeAliasName">FalseType</span></span></pre></p>
<p>When the type on the left of the <code>extends</code> is assignable to the one on the right, then you'll get the type in the first branch (the "true" branch); otherwise you'll get the type in the latter branch (the "false" branch).</p>
<p>From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not <code>Dog extends Animal</code> and pick <code>number</code> or <code>string</code>!
But the power of conditional types comes from using them with generics.</p>
<p>For example, let's take the following <code>createLabel</code> function:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">IdLabel</span></span> { <span class="tm-vr">id</span>: <span class="tm-typ">number</span>, <span class="tm-cmt">/* some fields */</span> }
<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">NameLabel</span></span> { <span class="tm-vr">name</span>: <span class="tm-typ">string</span>, <span class="tm-cmt">/* other fields */</span> }

<span class="tm-kw">function</span> <span class="tm-mth">createLabel</span>(<span class="tm-vr">id</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">IdLabel</span></span>;
<span class="tm-kw">function</span> <span class="tm-mth">createLabel</span>(<span class="tm-vr">name</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> <span class="interfaceName">NameLabel</span></span>;
<span class="tm-kw">function</span> <span class="tm-mth">createLabel</span>(<span class="tm-vr">nameOrId</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">IdLabel</span> </span>|<span class="tm-typ"> <span class="interfaceName">NameLabel</span></span>;
<span class="tm-kw">function</span> <span class="tm-mth">createLabel</span>(<span class="tm-vr">nameOrId</span>: <span class="tm-typ">string</span> | <span class="tm-typ">number</span>):<span class="tm-typ"> <span class="interfaceName">IdLabel</span> </span>|<span class="tm-typ"> <span class="interfaceName">NameLabel</span> </span>{
    <span class="tm-kw">throw</span> <span class="tm-str">"unimplemented"</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20IdLabel%20%7B%20id%3A%20number%2C%20%2F*%20some%20fields%20*%2F%20%7D%0Ainterface%20NameLabel%20%7B%20name%3A%20string%2C%20%2F*%20other%20fields%20*%2F%20%7D%0A%0Afunction%20createLabel(id%3A%20number)%3A%20IdLabel%3B%0Afunction%20createLabel(name%3A%20string)%3A%20NameLabel%3B%0Afunction%20createLabel(nameOrId%3A%20string%20%7C%20number)%3A%20IdLabel%20%7C%20NameLabel%3B%0Afunction%20createLabel(nameOrId%3A%20string%20%7C%20number)%3A%20IdLabel%20%7C%20NameLabel%20%7B%0A%20%20%20%20throw%20%22unimplemented%22%3B%0A%7D">Try</a></pre></p>
<p>These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:</p>
<ol>
<li>If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.</li>
<li>We have to create three overloads: one for each case when we're <em>sure</em> of the type (one for <code>string</code> and one for <code>number</code>), and one for the most general case (taking a <code>string | number</code>). For every new type <code>createLabel</code> can handle, the number of overloads grows exponentially.</li>
</ol>
<p>Instead, we can encode that logic in a conditional type:</p>
<p><pre class="typescript-code">
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">NameOrId</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> <span class="tm-typ">number</span> | <span class="tm-typ">string</span>> =
    <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> <span class="tm-typ">number</span> ? <span class="tm-typ"><span class="interfaceName">IdLabel</span></span> : <span class="tm-typ"><span class="interfaceName">NameLabel</span></span>;</pre></p>
<p>We can then use that conditional type to simplify out overloads down to a single function with no overloads.</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">createLabel</span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> <span class="tm-typ">number</span> | <span class="tm-typ">string</span>>(<span class="tm-vr">idOrName</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>):<span class="tm-typ"> <span class="typeAliasName">NameOrId</span><<span class="typeParameterName">T</span>> </span>{
    <span class="tm-kw">throw</span> <span class="tm-str">"unimplemented"</span>
}

<span class="tm-kw">let</span> <span class="tm-vr">a</span> = <span class="tm-mth">createLabel</span>(<span class="tm-str">"typescript"</span>);
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">a</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">NameLabel</span></span>

<span class="tm-kw">let</span> <span class="tm-vr">b</span> = <span class="tm-mth">createLabel</span>(<span class="tm-num">2.8</span>);
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">b</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">IdLabel</span></span>

<span class="tm-kw">let</span> <span class="tm-vr">c</span> = <span class="tm-mth">createLabel</span>(<span class="tm-typ">Math</span>.<span class="tm-mth">random</span>() ? <span class="tm-str">"hello"</span> : <span class="tm-num">42</span>);
    <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">let</span><span class="space"> </span><span class="localName">c</span><span class="punctuation">:</span><span class="space"> </span><span class="interfaceName">IdLabel</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="interfaceName">NameLabel</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20IdLabel%20%7B%20id%3A%20number%2C%20%2F*%20some%20fields%20*%2F%20%7D%0Ainterface%20NameLabel%20%7B%20name%3A%20string%2C%20%2F*%20other%20fields%20*%2F%20%7D%0Atype%20NameOrId%3CT%20extends%20number%20%7C%20string%3E%20%3D%0A%20%20%20%20T%20extends%20number%20%3F%20IdLabel%20%3A%20NameLabel%3B%0A%2F%2Fcut%0Afunction%20createLabel%3CT%20extends%20number%20%7C%20string%3E(idOrName%3A%20T)%3A%20NameOrId%3CT%3E%20%7B%0A%20%20%20%20throw%20%22unimplemented%22%0A%7D%0A%0Alet%20a%20%3D%20createLabel(%22typescript%22)%3B%0A%0Alet%20b%20%3D%20createLabel(2.8)%3B%0A%0Alet%20c%20%3D%20createLabel(Math.random()%20%3F%20%22hello%22%20%3A%2042)%3B">Try</a></pre></p>
<h3 id="conditional-type-constraints"><a href="#conditional-type-constraints">Conditional Type Constraints</h3></a>
<p>Often, the checks in a conditional type will provide us with some new information.
Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constraint generics by the type we check against.</p>
<p>For example, let's take the following:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="error" tabindex="0" aria-describedby="errLabel-2536-20-12"><span class="error-highlight"></span><span class="tm-typ"><span class="typeParameterName">T</span></span>[<span class="tm-str">"message"</span>]<span id="errLabel-2536-20-12" role="tooltip" class="error-tooltip">Type '"message"' cannot be used to index type 'T'.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Type '"message"' cannot be used to index type 'T'.</div></div></pre></p>
<p>In this example, TypeScript errors because <code>T</code> isn't known to have a property called <code>message</code>.
We could constrain <code>T</code>, and TypeScript would no longer complain:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-kw">extends</span> { <span class="tm-vr">message</span>: <span class="tm-typ">unknown</span> }> = <span class="tm-typ"><span class="typeParameterName">T</span></span>[<span class="tm-str">"message"</span>];

<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Email</span></span> {
    <span class="tm-vr">message</span>: <span class="tm-typ">string</span>;
}

<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Dog</span></span> {
    <span class="tm-mth">bark</span>():<span class="tm-typ"> void</span>;
}

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">EmailMessageContents</span></span> = <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="interfaceName">Email</span></span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">EmailMessageContents</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20MessageOf%3CT%20extends%20%7B%20message%3A%20unknown%20%7D%3E%20%3D%20T%5B%22message%22%5D%3B%0A%0Ainterface%20Email%20%7B%0A%20%20%20%20message%3A%20string%3B%0A%7D%0A%0Ainterface%20Dog%20%7B%0A%20%20%20%20bark()%3A%20void%3B%0A%7D%0A%0Atype%20EmailMessageContents%20%3D%20MessageOf%3CEmail%3E%3B">Try</a></pre></p>
<p>However, what if we wanted <code>MessageOf</code> to take any type, and default to something like <code>never</code> if a <code>message</code> property isn't available?
We can do this by moving the constraint out and introducing a conditional type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> { <span class="tm-vr">message</span>: <span class="tm-typ">unknown</span> } ? <span class="tm-typ"><span class="typeParameterName">T</span></span>[<span class="tm-str">"message"</span>] : <span class="tm-typ">never</span>;

<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Email</span></span> { <span class="tm-vr">message</span>: <span class="tm-typ">string</span> }

<span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Dog</span></span> { <span class="tm-mth">bark</span>():<span class="tm-typ"> void </span>}

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">EmailMessageContents</span></span> = <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="interfaceName">Email</span></span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">EmailMessageContents</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">DogMessageContents</span></span> = <span class="tm-typ"><span class="typeAliasName">MessageOf</span></span><<span class="tm-typ"><span class="interfaceName">Dog</span></span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">DogMessageContents</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">never</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20MessageOf%3CT%3E%20%3D%20T%20extends%20%7B%20message%3A%20unknown%20%7D%20%3F%20T%5B%22message%22%5D%20%3A%20never%3B%0A%0Ainterface%20Email%20%7B%20message%3A%20string%20%7D%0A%0Ainterface%20Dog%20%7B%20bark()%3A%20void%20%7D%0A%0Atype%20EmailMessageContents%20%3D%20MessageOf%3CEmail%3E%3B%0A%0Atype%20DogMessageContents%20%3D%20MessageOf%3CDog%3E%3B">Try</a></pre></p>
<p>Within the true branch, TypeScript knows that <code>T</code> <em>will</em> have a <code>message</code> property.</p>
<p>As another example, we could also write a type called <code>Flatten</code> that flattens array types to their element types, but leaves them alone otherwise:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Flatten</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> <span class="tm-typ">any</span>[] ? <span class="tm-typ"><span class="typeParameterName">T</span></span>[<span class="tm-typ">number</span>] : <span class="tm-typ"><span class="typeParameterName">T</span></span>

<span class="tm-cmt">// Extracts out the element type.</span>
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Str</span></span> = <span class="tm-typ"><span class="typeAliasName">Flatten</span></span><<span class="tm-typ">string</span>[]>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Str</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span></span>

<span class="tm-cmt">// Leaves the type alone.</span>
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Num</span></span> = <span class="tm-typ"><span class="typeAliasName">Flatten</span></span><<span class="tm-typ">number</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Num</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">number</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Flatten%3CT%3E%20%3D%20T%20extends%20any%5B%5D%20%3F%20T%5Bnumber%5D%20%3A%20T%0A%0A%2F%2F%20Extracts%20out%20the%20element%20type.%0Atype%20Str%20%3D%20Flatten%3Cstring%5B%5D%3E%3B%0A%0A%2F%2F%20Leaves%20the%20type%20alone.%0Atype%20Num%20%3D%20Flatten%3Cnumber%3E%3B">Try</a></pre></p>
<p>When <code>Flatten</code> is given an array type, it uses an indexed access with <code>number</code> to fetch out <code>string[]</code>'s element type.
Otherwise, it just returns the type it was given.</p>
<h3 id="inferring-within-conditional-types"><a href="#inferring-within-conditional-types">Inferring Within Conditional Types</h3></a>
<p>We just found ourselves using conditional types to apply constraints and then extract out types.
This ends up being such a common operation that conditional types make it easier.</p>
<p>Conditional types provide us with a way to infer from types we compare against in the true branch using the <code>infer</code> keyword.
For example, we could have inferred the element type in <code>Flatten</code> instead of fetching it out "manually" with an indexed access type:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Flatten</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> <span class="tm-typ"><span class="interfaceName">Array</span></span><<span class="tm-typ">infer</span> <span class="tm-typ"><span class="typeParameterName">U</span></span>> ? <span class="tm-typ"><span class="typeParameterName">U</span></span> : <span class="tm-typ"><span class="typeParameterName">T</span></span>;</pre></p>
<p>Here, we used the <code>infer</code> keyword declaratively introduced a new generic type variable named <code>U</code> instead of specifying how to retrieve the element type of <code>T</code>.
Within the true branch
This frees us from having to think about how to dig through and probing apart the structure of the types we're interested.</p>
<p>We can write some useful helper type aliases using the <code>infer</code> keyword.
For example, for simple cases, we can extract the return type out from function types:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">GetReturnType</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> =
    <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> (...<span class="tm-vr">args</span>: <span class="tm-typ">never</span>[]) <span class="tm-kw">=></span> <span class="tm-typ">infer</span> <span class="tm-typ"><span class="typeParameterName">U</span></span> ? <span class="tm-typ"><span class="typeParameterName">U</span></span> : <span class="tm-typ">never</span>;

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Foo</span></span> = <span class="tm-typ"><span class="typeAliasName">GetReturnType</span></span><() <span class="tm-kw">=></span> <span class="tm-typ">number</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Foo</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">number</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Bar</span></span> = <span class="tm-typ"><span class="typeAliasName">GetReturnType</span></span><(<span class="tm-vr">x</span>: <span class="tm-typ">string</span>) <span class="tm-kw">=></span> <span class="tm-typ">string</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Bar</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span></span>

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Baz</span></span> = <span class="tm-typ"><span class="typeAliasName">GetReturnType</span></span><(<span class="tm-vr">a</span>: <span class="tm-typ">boolean</span>, <span class="tm-vr">b</span>: <span class="tm-typ">boolean</span>) <span class="tm-kw">=></span> <span class="tm-typ">boolean</span>[]>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Baz</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">boolean</span><span class="punctuation">[</span><span class="punctuation">]</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20GetReturnType%3CT%3E%20%3D%0A%20%20%20%20T%20extends%20(...args%3A%20never%5B%5D)%20%3D%3E%20infer%20U%20%3F%20U%20%3A%20never%3B%0A%0Atype%20Foo%20%3D%20GetReturnType%3C()%20%3D%3E%20number%3E%3B%0A%0Atype%20Bar%20%3D%20GetReturnType%3C(x%3A%20string)%20%3D%3E%20string%3E%3B%0A%0Atype%20Baz%20%3D%20GetReturnType%3C(a%3A%20boolean%2C%20b%3A%20boolean)%20%3D%3E%20boolean%5B%5D%3E%3B">Try</a></pre></p>
<h2 id="distributive-conditional-types"><a href="#distributive-conditional-types">Distributive Conditional Types</h2></a>
<p>When conditional types act on a generic type, they become <em>distributive</em> when given a union type.
For example, take the following:</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> <span class="tm-typ">any</span> ? <span class="tm-typ"><span class="typeParameterName">T</span></span>[] : <span class="tm-typ">never</span>;</pre></p>
<p>If we plug a union type into <code>Foo</code>, then the conditional type will be applied to each member of that union.</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = <span class="tm-typ"><span class="typeParameterName">T</span></span> <span class="tm-typ">extends</span> <span class="tm-typ">any</span> ? <span class="tm-typ"><span class="typeParameterName">T</span></span>[] : <span class="tm-typ">never</span>;

<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Bar</span></span> = <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ">string</span> | <span class="tm-typ">number</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Bar</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="keyword">string</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span><span class="punctuation">[</span><span class="punctuation">]</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Foo%3CT%3E%20%3D%20T%20extends%20any%20%3F%20T%5B%5D%20%3A%20never%3B%0A%0Atype%20Bar%20%3D%20Foo%3Cstring%20%7C%20number%3E%3B">Try</a></pre></p>
<p>What happens here is that <code>Foo</code> distributes on</p>
<p><pre class="typescript-code">
<span class="tm-typ">string</span> | <span class="tm-typ">number</span></pre></p>
<p>and maps over each member type of the union, to what is effectively</p>
<p><pre class="typescript-code">
<span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ">string</span>> | <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ">number</span>></pre></p>
<p>which leaves us with</p>
<p><pre class="typescript-code">
<span class="tm-typ">string</span>[] | <span class="tm-typ">number</span>[]</pre></p>
<p>Typically, distributivity is the desired behavior.
To avoid that behavior, you can surround each side of the <code>extends</code> keyword with square brackets.</p>
<p><pre class="typescript-code"><span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> = [<span class="tm-typ"><span class="typeParameterName">T</span></span>] <span class="tm-typ">extends</span> [<span class="tm-typ">any</span>] ? <span class="tm-typ"><span class="typeParameterName">T</span></span>[] : <span class="tm-typ">never</span>;

<span class="tm-cmt">// 'Bar' is no longer a union.</span>
<span class="tm-kw">type</span> <span class="tm-typ"><span class="typeAliasName">Bar</span></span> = <span class="tm-typ"><span class="typeAliasName">Foo</span></span><<span class="tm-typ">string</span> | <span class="tm-typ">number</span>>;
     <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">type</span><span class="space"> </span><span class="aliasName">Bar</span><span class="space"> </span><span class="operator">=</span><span class="space"> </span><span class="punctuation">(</span><span class="keyword">string</span><span class="space"> </span><span class="punctuation">|</span><span class="space"> </span><span class="keyword">number</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">]</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20Foo%3CT%3E%20%3D%20%5BT%5D%20extends%20%5Bany%5D%20%3F%20T%5B%5D%20%3A%20never%3B%0A%0A%2F%2F%20'Bar'%20is%20no%20longer%20a%20union.%0Atype%20Bar%20%3D%20Foo%3Cstring%20%7C%20number%3E%3B">Try</a></pre></p><hr><h1 id="classes"><a href="#classes">Classes</h1></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Background reading: Classes (MDN)</a></p>
  </aside>
<p>TypeScript offers full support for the <code>class</code> keyword introduced in ES2015.
As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.</p>
<div class="toc"><span class="toc-title">Table of Contents</span><ul><li><a href="#class-members">Class Members</a></li><ul><li><a href="#fields">Fields</a></li><ul><li><a href="#--strictpropertyinitialization"><code>--strictPropertyInitialization</code></a></li></ul><li><a href="#readonly-class-properties"><code>readonly</code></a></li><li><a href="#constructors">Constructors</a></li><ul><li><a href="#super-calls">Super Calls</a></li></ul><li><a href="#methods">Methods</a></li><li><a href="#getters--setters">Getters / Setters</a></li><li><a href="#class-index-signatures">Index Signatures</a></li></ul><li><a href="#class-heritage">Class Heritage</a></li><ul><li><a href="#implements-clauses"><code>implements</code> Clauses</a></li><ul><li><a href="#cautions">Cautions</a></li></ul><li><a href="#extends-clauses"><code>extends</code> Clauses</a></li><ul><li><a href="#overriding-methods">Overriding Methods</a></li><li><a href="#initialization-order">Initialization Order</a></li><li><a href="#inheriting-built-in-types">Inheriting Built-in Types</a></li></ul></ul><li><a href="#member-visibility">Member Visibility</a></li><ul><li><a href="#public"><code>public</code></a></li><li><a href="#protected"><code>protected</code></a></li><ul><li><a href="#exposure-of-protected-members">Exposure of <code>protected</code> members</a></li><li><a href="#cross-hierarchy-protected-access">Cross-hierarchy <code>protected</code> access</a></li></ul><li><a href="#private"><code>private</code></a></li><ul><li><a href="#cross-instance-private-access">Cross-instance <code>private</code> access</a></li><li><a href="#private-and-runtime-privacy">Caveats</a></li></ul></ul><li><a href="#static-members">Static Members</a></li><ul><li><a href="#special-static-names">Special Static Names</a></li><li><a href="#why-no-static-classes?">Why No Static Classes?</a></li></ul><li><a href="#generic-classes">Generic Classes</a></li><ul><li><a href="#type-parameters-in-static-members">Type Parameters in Static Members</a></li></ul><li><a href="#runtime-this-in-classes"><code>this</code> at Runtime in Classes</a></li><ul><li><a href="#arrow-functions">Arrow Functions</a></li><li><a href="#this-parameters"><code>this</code> parameters</a></li></ul><li><a href="#this-types"><code>this</code> Types</a></li><li><a href="#parameter-properties">Parameter Properties</a></li><li><a href="#class-expressions">Class Expressions</a></li><li><a href="#abstract-classes-and-members"><code>abstract</code> Classes and Members</a></li><ul><li><a href="#abstract-construct-signatures">Abstract Construct Signatures</a></li></ul><li><a href="#relationships-between-classes">Relationships Between Classes</a></li></ul></ul></div>
<h2 id="class-members"><a href="#class-members">Class Members</h2></a>
<p>Here's the most basic class - an empty one:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {

}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%0A%7D">Try</a></pre></p>
<p>This class isn't very useful yet, so let's start adding some members.</p>
<h3 id="fields"><a href="#fields">Fields</h3></a>
<p>A field declaration creates a public writeable property on a class:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {
    <span class="tm-vr">x</span>: <span class="tm-typ">number</span>;
    <span class="tm-vr">y</span>: <span class="tm-typ">number</span>;
}

<span class="tm-kw">const</span> <span class="tm-vr">pt</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Point</span></span>();
<span class="tm-vr">pt</span>.<span class="tm-vr">x</span> = <span class="tm-num">0</span>;
<span class="tm-vr">pt</span>.<span class="tm-vr">y</span> = <span class="tm-num">0</span>;<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%20%20%20%20x%3A%20number%3B%0A%20%20%20%20y%3A%20number%3B%0A%7D%0A%0Aconst%20pt%20%3D%20new%20Point()%3B%0Apt.x%20%3D%200%3B%0Apt.y%20%3D%200%3B">Try</a></pre></p>
<p>As with other locations, the type annotation is optional, but will be an implict <code>any</code> if not specified.</p>
<p>Fields can also have <em>initializers</em>; these will run automatically when the class is instantiated:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {
    <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
    <span class="tm-vr">y</span> = <span class="tm-num">0</span>;
}

<span class="tm-kw">const</span> <span class="tm-vr">pt</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Point</span></span>();
<span class="tm-cmt">// Prints 0, 0</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`</span><span class="tm-kw">${</span><span class="tm-vr">pt</span><span class="tm-str">.</span><span class="tm-vr">x</span><span class="tm-kw">}</span><span class="tm-str">, </span><span class="tm-kw">${</span><span class="tm-vr">pt</span><span class="tm-str">.</span><span class="tm-vr">y</span><span class="tm-kw">}</span><span class="tm-str">`</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20y%20%3D%200%3B%0A%7D%0A%0Aconst%20pt%20%3D%20new%20Point()%3B%0A%2F%2F%20Prints%200%2C%200%0Aconsole.log(%60%24%7Bpt.x%7D%2C%20%24%7Bpt.y%7D%60)%3B">Try</a></pre></p>
<p>Just like with <code>const</code>, <code>let</code>, and <code>var</code>, the initializer of a class property will be used to infer its type:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">pt</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Point</span></span>();
<span class="error" tabindex="0" aria-describedby="errLabel-2322-68-4"><span class="error-highlight"></span><span class="tm-vr">pt</span>.<span class="tm-vr">x</span><span id="errLabel-2322-68-4" role="tooltip" class="error-tooltip">Type '"0"' is not assignable to type 'number'.</span></span> = <span class="tm-str">"0"</span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Type '"0"' is not assignable to type 'number'.</div></div></pre></p>
<h4 id="--strictpropertyinitialization"><a href="#--strictpropertyinitialization"><code>--strictPropertyInitialization</code></h4></a>
<p>The <code>strictPropertyInitialization</code> setting controls whether class fields need to be initialized in the constructor.</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">BadGreeter</span></span> {
  <span class="error" tabindex="0" aria-describedby="errLabel-2564-21-4"><span class="error-highlight"></span><span class="tm-vr">name</span><span id="errLabel-2564-21-4" role="tooltip" class="error-tooltip">Property 'name' has no initializer and is not definitely assigned in the constructor.</span></span>: <span class="tm-typ">string</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'name' has no initializer and is not definitely assigned in the constructor.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20BadGreeter%20%7B%0A%20%20name%3A%20string%3B%0A%7D">Try</a></pre></p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">GoodGreeter</span></span> {
  <span class="tm-vr">name</span>: <span class="tm-typ">string</span>;

  <span class="tm-kw">constructor</span>() {
    <span class="tm-kw">this</span>.<span class="tm-vr">name</span> = <span class="tm-str">"hello"</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20GoodGreeter%20%7B%0A%20%20name%3A%20string%3B%0A%0A%20%20constructor()%20%7B%0A%20%20%20%20this.name%20%3D%20%22hello%22%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Note that the field needs to be initialized <em>in the constructor itself</em>.
TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.</p>
<p>If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the <em>definite assignment assertion operator</em>, <code>!</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">OKGreeter</span></span> {
  <span class="tm-cmt">// Not initialized, but no error</span>
  <span class="tm-vr">name</span>!: <span class="tm-typ">string</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20OKGreeter%20%7B%0A%20%20%2F%2F%20Not%20initialized%2C%20but%20no%20error%0A%20%20name!%3A%20string%3B%0A%7D">Try</a></pre></p>
<h3 id="readonly-class-properties"><a href="#readonly-class-properties"><code>readonly</code></h3></a>
<p>Fields may be prefixed with the <code>readonly</code> modifier.
This prevents assignments to the field outside of the constructor.</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Greeter</span></span> {
  <span class="tm-kw">readonly</span> <span class="tm-vr">name</span>: <span class="tm-typ">string</span> = <span class="tm-str">"world"</span>;

  <span class="tm-kw">constructor</span>(<span class="tm-vr">otherName</span>?: <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">otherName</span> !== <span class="tm-kw">undefined</span>) {
      <span class="tm-kw">this</span>.<span class="tm-vr">name</span> = <span class="tm-vr">otherName</span>;
    }
  }

  <span class="tm-mth">err</span>() {
    <span class="tm-kw">this</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2540-182-4"><span class="error-highlight"></span><span class="tm-vr">name</span><span id="errLabel-2540-182-4" role="tooltip" class="error-tooltip">Cannot assign to 'name' because it is a read-only property.</span></span> = <span class="tm-str">"not ok"</span>;
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">g</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Greeter</span></span>();
<span class="tm-vr">g</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2540-232-4"><span class="error-highlight"></span><span class="tm-vr">name</span><span id="errLabel-2540-232-4" role="tooltip" class="error-tooltip">Cannot assign to 'name' because it is a read-only property.</span></span> = <span class="tm-str">"also not ok"</span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Cannot assign to 'name' because it is a read-only property.</div></div><div class="listed-error"><div class="error-line">Cannot assign to 'name' because it is a read-only property.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Greeter%20%7B%0A%20%20readonly%20name%3A%20string%20%3D%20%22world%22%3B%0A%0A%20%20constructor(otherName%3F%3A%20string)%20%7B%0A%20%20%20%20if%20(otherName%20!%3D%3D%20undefined)%20%7B%0A%20%20%20%20%20%20this.name%20%3D%20otherName%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%0A%20%20err()%20%7B%0A%20%20%20%20this.name%20%3D%20%22not%20ok%22%3B%0A%20%20%7D%0A%7D%0Aconst%20g%20%3D%20new%20Greeter()%3B%0Ag.name%20%3D%20%22also%20not%20ok%22%3B">Try</a></pre></p>
<h3 id="constructors"><a href="#constructors">Constructors</h3></a>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">Background Reading: Constructor (MDN)</a></p>
<p>Class constructors are very similar to functions.
You can add parameters with type annotations, default values, and overloads:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {
  <span class="tm-vr">x</span>: <span class="tm-typ">number</span>;
  <span class="tm-vr">y</span>: <span class="tm-typ">number</span>;

  <span class="tm-cmt">// Normal signature with defaults</span>
  <span class="tm-kw">constructor</span>(<span class="tm-vr">x</span> = <span class="tm-num">0</span>, <span class="tm-vr">y</span> = <span class="tm-num">0</span>) {
    <span class="tm-kw">this</span>.<span class="tm-vr">x</span> = <span class="tm-vr">x</span>;
    <span class="tm-kw">this</span>.<span class="tm-vr">y</span> = <span class="tm-vr">y</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%20%20x%3A%20number%3B%0A%20%20y%3A%20number%3B%0A%0A%20%20%2F%2F%20Normal%20signature%20with%20defaults%0A%20%20constructor(x%20%3D%200%2C%20y%20%3D%200)%20%7B%0A%20%20%20%20this.x%20%3D%20x%3B%0A%20%20%20%20this.y%20%3D%20y%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {
  <span class="tm-cmt">// Overloads</span>
  <span class="tm-kw">constructor</span>(<span class="tm-vr">x</span>: <span class="tm-typ">number</span>, <span class="tm-vr">y</span>: <span class="tm-typ">string</span>);
  <span class="tm-kw">constructor</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>);
  <span class="tm-kw">constructor</span>(<span class="tm-vr">xs</span>: <span class="tm-typ">any</span>, <span class="tm-vr">y</span>?: <span class="tm-typ">any</span>) {
    <span class="tm-cmt">// TBD</span>
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%20%20%2F%2F%20Overloads%0A%20%20constructor(x%3A%20number%2C%20y%3A%20string)%3B%0A%20%20constructor(s%3A%20string)%3B%0A%20%20constructor(xs%3A%20any%2C%20y%3F%3A%20any)%20%7B%0A%20%20%20%20%2F%2F%20TBD%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>There are just a few differences between class constructor signatures and function signatures:</p>
<ul>
<li>Constructors can't have type parameters - these belong on the outer class declaration, which we'll learn about later</li>
<li>Constructors can't have return type annotations - the class instance type is always what's returned</li>
</ul>
<h4 id="super-calls"><a href="#super-calls">Super Calls</h4></a>
<p>Just as in JavaScript, if you have a base class, you'll need to call <code>super();</code> in your constructor body before using any <code>this.</code> members:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-vr">k</span> = <span class="tm-num">4</span>;
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-kw">constructor</span>() {
    <span class="tm-cmt">// Prints a wrong value in ES5; throws exception in ES6</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="error" tabindex="0" aria-describedby="errLabel-17009-148-4"><span class="error-highlight"></span><span class="tm-kw">this</span><span id="errLabel-17009-148-4" role="tooltip" class="error-tooltip">'super' must be called before accessing 'this' in the constructor of a derived class.</span></span>.<span class="tm-vr">k</span>);
    <span class="tm-kw">super</span>();
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">'super' must be called before accessing 'this' in the constructor of a derived class.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20k%20%3D%204%3B%0A%7D%0A%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20%2F%2F%20Prints%20a%20wrong%20value%20in%20ES5%3B%20throws%20exception%20in%20ES6%0A%20%20%20%20console.log(this.k)%3B%0A%20%20%20%20super()%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Forgetting to call <code>super</code> is an easy mistake to make in JavaScript, but TypeScript will tell you when it's necessary.</p>
<h3 id="methods"><a href="#methods">Methods</h3></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">Background Reading: Method definitions (MDN)</a></p>
  </aside>
<p>A function property on a class is called a <em>method</em>.
Methods can use all the same type annotations as functions and constructors:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point</span></span> {
  <span class="tm-vr">x</span> = <span class="tm-num">10</span>;
  <span class="tm-vr">y</span> = <span class="tm-num">10</span>;

  <span class="tm-mth">scale</span>(<span class="tm-vr">n</span>: <span class="tm-typ">number</span>):<span class="tm-typ"> void </span>{
    <span class="tm-kw">this</span>.<span class="tm-vr">x</span> *= <span class="tm-vr">n</span>;
    <span class="tm-kw">this</span>.<span class="tm-vr">y</span> *= <span class="tm-vr">n</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point%20%7B%0A%20%20x%20%3D%2010%3B%0A%20%20y%20%3D%2010%3B%0A%0A%20%20scale(n%3A%20number)%3A%20void%20%7B%0A%20%20%20%20this.x%20*%3D%20n%3B%0A%20%20%20%20this.y%20*%3D%20n%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Other than the standard type annotations, TypeScript doesn't add anything else new to methods.</p>
<p>Note that inside a method body, it is still mandatory to access fields and other methods via <code>this.</code>.
An unqualified name in a method body will always refer to something in the enclosing scope:</p>
<p><pre class="typescript-code"><span class="tm-kw">let</span> <span class="tm-vr">x</span>: <span class="tm-typ">number</span> = <span class="tm-num">0</span>;

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">C</span></span> {
  <span class="tm-vr">x</span>: <span class="tm-typ">string</span> = <span class="tm-str">"hello"</span>;

  <span class="tm-mth">m</span>() {
    <span class="tm-cmt">// This is trying to modify 'x' from line 1, not the class property</span>
    <span class="error" tabindex="0" aria-describedby="errLabel-2322-138-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2322-138-1" role="tooltip" class="error-tooltip">Type '"world"' is not assignable to type 'number'.</span></span> = <span class="tm-str">"world"</span>;
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Type '"world"' is not assignable to type 'number'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=let%20x%3A%20number%20%3D%200%3B%0A%0Aclass%20C%20%7B%0A%20%20x%3A%20string%20%3D%20%22hello%22%3B%0A%0A%20%20m()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20trying%20to%20modify%20'x'%20from%20line%201%2C%20not%20the%20class%20property%0A%20%20%20%20x%20%3D%20%22world%22%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h3 id="getters--setters"><a href="#getters--setters">Getters / Setters</h3></a>
<p>Classes can also have <em>accessors</em>:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">C</span></span> {
  <span class="tm-vr">_length</span> = <span class="tm-num">0</span>;
  <span class="tm-kw">get</span> <span class="tm-mth">length</span>() {
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>.<span class="tm-vr">_length</span>;
  }
  <span class="tm-kw">set</span> <span class="tm-mth">length</span>(<span class="tm-vr">value</span>) {
    <span class="tm-kw">this</span>.<span class="tm-vr">_length</span> = <span class="tm-vr">value</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20C%20%7B%0A%20%20_length%20%3D%200%3B%0A%20%20get%20length()%20%7B%0A%20%20%20%20return%20this._length%3B%0A%20%20%7D%0A%20%20set%20length(value)%20%7B%0A%20%20%20%20this._length%20%3D%20value%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<blockquote>
  <p>Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript.
  It's fine to expose public fields if you don't need to add additional logic during the get/set operations.</p>
</blockquote>
<p>TypeScript has some special inference rules for accessors:</p>
<ul>
<li>If no <code>set</code> exists, the property is automatically <code>readonly</code></li>
<li>The type of the setter parameter is inferred from the return type of the getter</li>
<li>If the setter parameter has a type annotation, it must match the return type of the getter</li>
<li>Getters and setters must have the same <a href="/chapters/classes#member-visibility">Member Visibility</a></li>
</ul>
<p>It is not possible to have accessors with different types for getting and setting.</p>
<p>If you have a getter without a setter, the field is automatically <code>readonly</code></p>
<h3 id="class-index-signatures"><a href="#class-index-signatures">Index Signatures</h3></a>
<p>Classes can declare index signatures; these work the same as <a href="/chapters/object-types#index-signatures">Index Signatures</a> for other object types:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  [<span class="tm-vr">s</span>: <span class="tm-typ">string</span>]: <span class="tm-typ">boolean</span> | ((<span class="tm-vr">s</span>: <span class="tm-typ">string</span>) <span class="tm-kw">=></span> <span class="tm-typ">boolean</span>);
  <span class="tm-mth">check</span>(<span class="tm-vr">s</span>: <span class="tm-typ">string</span>) {
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>[<span class="tm-vr">s</span>] <span class="tm-kw">as</span> <span class="tm-typ">boolean</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20%5Bs%3A%20string%5D%3A%20boolean%20%7C%20((s%3A%20string)%20%3D%3E%20boolean)%3B%0A%20%20check(s%3A%20string)%20%7B%0A%20%20%20%20return%20this%5Bs%5D%20as%20boolean%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Because the index signature type needs to also capture the types of methods, it's not easy to usefully use these types.
Generally it's better to store indexed data in another place instead of on the class instance itself.</p>
<h2 id="class-heritage"><a href="#class-heritage">Class Heritage</h2></a>
<p>Like other langauges with object-oriented features, classes in JavaScript can inherit from base classes.</p>
<h3 id="implements-clauses"><a href="#implements-clauses"><code>implements</code> Clauses</h3></a>
<p>You can use an <code>implements</code> clause to check that a class satisfies a particular <code>interface</code>.
An error will be issued if a class fails to correctly implement it:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Pingable</span></span> {
  <span class="tm-mth">ping</span>():<span class="tm-typ"> void</span>;
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Sonar</span></span> <span class="tm-kw">implements</span> <span class="interfaceName">Pingable</span> {
  <span class="tm-mth">ping</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">'ping!'</span>);
  }
}

<span class="tm-kw">class</span> <span class="error" tabindex="0" aria-describedby="errLabel-2420-124-4"><span class="error-highlight"></span><span class="tm-typ"><span class="className">Ball</span></span><span id="errLabel-2420-124-4" role="tooltip" class="error-tooltip">Class 'Ball' incorrectly implements interface 'Pingable'.
  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.</span></span> <span class="tm-kw">implements</span> <span class="interfaceName">Pingable</span> {
  <span class="tm-mth">pong</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">'pong!'</span>);
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Class 'Ball' incorrectly implements interface 'Pingable'.</div><div class="error-line"><div class="indent"></div>Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Pingable%20%7B%0A%20%20ping()%3A%20void%3B%0A%7D%0A%0Aclass%20Sonar%20implements%20Pingable%20%7B%0A%20%20ping()%20%7B%0A%20%20%20%20console.log('ping!')%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Ball%20implements%20Pingable%20%7B%0A%20%20pong()%20%7B%0A%20%20%20%20console.log('pong!')%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Classes may also implement multiple interfaces, e.g. <code>class C implements A, B {</code>.</p>
<h4 id="cautions"><a href="#cautions">Cautions</h4></a>
<p>It's important to understand that an <code>implements</code> clause is only a check that the class can be treated as the interface type.
It doesn't change the type of the class or its methods <em>at all</em>.
A common source of error is to assume that an <code>implements</code> clause will change the class type - it doesn't!</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">Checkable</span></span> {
  <span class="tm-mth">check</span>(<span class="tm-vr">name</span>: <span class="tm-typ">string</span>):<span class="tm-typ"> boolean</span>;
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">NameChecker</span></span> <span class="tm-kw">implements</span> <span class="interfaceName">Checkable</span> {
  <span class="tm-mth">check</span>(<span class="tm-vr">s</span>) {
    <span class="tm-cmt">// Notice no error here</span>
    <span class="tm-kw">return</span> <span class="tm-vr">s</span>.<span class="tm-mth">toLowercse</span>() === <span class="tm-str">"ok"</span>;
           <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">parameter</span><span class="punctuation">)</span><span class="space"> </span><span class="parameterName">s</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">any</span></span>
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20Checkable%20%7B%0A%20%20check(name%3A%20string)%3A%20boolean%3B%0A%7D%0Aclass%20NameChecker%20implements%20Checkable%20%7B%0A%20%20check(s)%20%7B%0A%20%20%20%20%2F%2F%20Notice%20no%20error%20here%0A%20%20%20%20return%20s.toLowercse()%20%3D%3D%3D%20%22ok%22%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>In this example, we perhaps expected that <code>s</code>'s type would be influenced by the <code>name: string</code> parameter of <code>check</code>.
It is not - <code>implements</code> clauses don't change how the class body is checked or its type inferred.</p>
<p>Similarly, implementing an interface with an optional property doesn't create that property:</p>
<p><pre class="typescript-code"><span class="tm-kw">interface</span> <span class="tm-typ"><span class="interfaceName">A</span></span> {
  <span class="tm-vr">x</span>: <span class="tm-typ">number</span>;
  <span class="tm-vr">y</span>?: <span class="tm-typ">number</span>;
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">C</span></span> <span class="tm-kw">implements</span> <span class="interfaceName">A</span> {
  <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
}
<span class="tm-kw">const</span> <span class="tm-vr">c</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">C</span></span>();
<span class="tm-vr">c</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2339-98-1"><span class="error-highlight"></span><span class="tm-vr">y</span><span id="errLabel-2339-98-1" role="tooltip" class="error-tooltip">Property 'y' does not exist on type 'C'.</span></span> = <span class="tm-num">10</span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'y' does not exist on type 'C'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=interface%20A%20%7B%0A%20%20x%3A%20number%3B%0A%20%20y%3F%3A%20number%3B%0A%7D%0Aclass%20C%20implements%20A%20%7B%0A%20%20x%20%3D%200%3B%0A%7D%0Aconst%20c%20%3D%20new%20C()%3B%0Ac.y%20%3D%2010%3B">Try</a></pre></p>
<h3 id="extends-clauses"><a href="#extends-clauses"><code>extends</code> Clauses</h3></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends">Background Reading: extends keyword (MDN)</a></p>
  </aside>
<p>Classes may <code>extend</code> from a base class.
A derived class has all the properties and methods of its base class, and also define additional members.</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Animal</span></span> {
  <span class="tm-mth">move</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Moving along!"</span>);
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Dog</span></span> <span class="tm-kw">extends</span> <span class="className">Animal</span> {
  <span class="tm-mth">woof</span>(<span class="tm-vr">times</span>: <span class="tm-typ">number</span>) {
    <span class="tm-kw">for</span> (<span class="tm-kw">let</span> <span class="tm-vr">i</span> = <span class="tm-num">0</span>; <span class="tm-vr">i</span> < <span class="tm-vr">times</span>; <span class="tm-vr">i</span>++) {
      <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"woof!"</span>);
    }
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">d</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Dog</span></span>();
<span class="tm-cmt">// Base class method</span>
<span class="tm-vr">d</span>.<span class="tm-mth">move</span>();
<span class="tm-cmt">// Derived class method</span>
<span class="tm-vr">d</span>.<span class="tm-mth">woof</span>(<span class="tm-num">3</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Animal%20%7B%0A%20%20move()%20%7B%0A%20%20%20%20console.log(%22Moving%20along!%22)%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Dog%20extends%20Animal%20%7B%0A%20%20woof(times%3A%20number)%20%7B%0A%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20times%3B%20i%2B%2B)%20%7B%0A%20%20%20%20%20%20console.log(%22woof!%22)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0Aconst%20d%20%3D%20new%20Dog()%3B%0A%2F%2F%20Base%20class%20method%0Ad.move()%3B%0A%2F%2F%20Derived%20class%20method%0Ad.woof(3)%3B">Try</a></pre></p>
<h4 id="overriding-methods"><a href="#overriding-methods">Overriding Methods</h4></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">Background reading: super keyword (MDN)</a></p>
  </aside>
<p>A derived class can also override a base class field or property.
You can use the <code>super.</code> syntax to access base class methods.
Note that because JavaScript classes are a simple lookup object, there is no notion of a "super field".</p>
<p>TypeScript enforces that a derived class is always a subtype of its base class.</p>
<p>For example, here's a legal way to override a method:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-mth">greet</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, world!"</span>);
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-mth">greet</span>(<span class="tm-vr">name</span>?: <span class="tm-typ">string</span>) {
    <span class="tm-kw">if</span> (<span class="tm-vr">name</span> === <span class="tm-kw">undefined</span>) {
      <span class="tm-kw">super</span>.<span class="tm-mth">greet</span>();
    } <span class="tm-kw">else</span> {
      <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello, </span><span class="tm-kw">${</span><span class="tm-vr">name</span><span class="tm-str">.</span><span class="tm-mth">toUpperCase</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">`</span>);
    }
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">d</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Derived</span></span>();
<span class="tm-vr">d</span>.<span class="tm-mth">greet</span>();
<span class="tm-vr">d</span>.<span class="tm-mth">greet</span>(<span class="tm-str">"reader"</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20greet()%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20world!%22)%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20greet(name%3F%3A%20string)%20%7B%0A%20%20%20%20if%20(name%20%3D%3D%3D%20undefined)%20%7B%0A%20%20%20%20%20%20super.greet()%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20console.log(%60Hello%2C%20%24%7Bname.toUpperCase()%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0Aconst%20d%20%3D%20new%20Derived()%3B%0Ad.greet()%3B%0Ad.greet(%22reader%22)%3B">Try</a></pre></p>
<p>It's important that a derived class follow its base class contract.
Remember that it's very common (and always legal!) to refer to a derived class instance through a base class reference:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// Alias the derived instance through a base class reference</span>
<span class="tm-kw">const</span> <span class="tm-vr">b</span>: <span class="tm-typ"><span class="className">Base</span></span> = <span class="tm-vr">d</span>;
<span class="tm-cmt">// No problem</span>
<span class="tm-vr">b</span>.<span class="tm-mth">greet</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20greet()%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20world!%22)%3B%0A%20%20%7D%0A%7D%0Adeclare%20const%20d%3A%20Base%3B%0A%2F%2Fcut%0A%2F%2F%20Alias%20the%20derived%20instance%20through%20a%20base%20class%20reference%0Aconst%20b%3A%20Base%20%3D%20d%3B%0A%2F%2F%20No%20problem%0Ab.greet()%3B">Try</a></pre></p>
<p>What if <code>Derived</code> didn't follow <code>Base</code>'s contract?</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-mth">greet</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, world!"</span>);
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-cmt">// Make this parameter required</span>
  <span class="error" tabindex="0" aria-describedby="errLabel-2416-131-5"><span class="error-highlight"></span><span class="tm-mth">greet</span><span id="errLabel-2416-131-5" role="tooltip" class="error-tooltip">Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
  Type '(name: string) => void' is not assignable to type '() => void'.</span></span>(<span class="tm-vr">name</span>: <span class="tm-typ">string</span>) {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">`Hello, </span><span class="tm-kw">${</span><span class="tm-vr">name</span><span class="tm-str">.</span><span class="tm-mth">toUpperCase</span><span class="tm-str">()</span><span class="tm-kw">}</span><span class="tm-str">`</span>);
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.</div><div class="error-line"><div class="indent"></div>Type '(name: string) => void' is not assignable to type '() => void'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20greet()%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20world!%22)%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20%2F%2F%20Make%20this%20parameter%20required%0A%20%20greet(name%3A%20string)%20%7B%0A%20%20%20%20console.log(%60Hello%2C%20%24%7Bname.toUpperCase()%7D%60)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>If we compiled this code despite the error, this sample would then crash:</p>
<p><pre class="typescript-code">
<span class="tm-kw">const</span> <span class="tm-vr">b</span>: <span class="tm-typ"><span class="className">Base</span></span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Derived</span></span>();
<span class="tm-cmt">// Crashes because "name" will be undefined</span>
<span class="tm-vr">b</span>.<span class="tm-mth">greet</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=declare%20class%20Base%20%20%7B%20greet()%3A%20void%20%7D%3B%0Adeclare%20class%20Derived%20extends%20Base%20%7B%20%7D%0A%2F%2Fcut%0Aconst%20b%3A%20Base%20%3D%20new%20Derived()%3B%0A%2F%2F%20Crashes%20because%20%22name%22%20will%20be%20undefined%0Ab.greet()%3B">Try</a></pre></p>
<h4 id="initialization-order"><a href="#initialization-order">Initialization Order</h4></a>
<p>The order that JavaScript classes initialize can be surprising in some cases.
Let's consider this code:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-vr">name</span> = <span class="tm-str">"base"</span>;
  <span class="tm-kw">constructor</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"My name is "</span> + <span class="tm-vr">name</span>);
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-vr">name</span> = <span class="tm-str">"derived"</span>;
}

<span class="tm-cmt">// Prints "base", not "derived"</span>
<span class="tm-kw">const</span> <span class="tm-vr">d</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Derived</span></span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20name%20%3D%20%22base%22%3B%0A%20%20constructor()%20%7B%0A%20%20%20%20console.log(%22My%20name%20is%20%22%20%2B%20name)%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20name%20%3D%20%22derived%22%3B%0A%7D%0A%0A%2F%2F%20Prints%20%22base%22%2C%20not%20%22derived%22%0Aconst%20d%20%3D%20new%20Derived()%3B">Try</a></pre></p>
<p>What happened here?</p>
<p>The order of class initialization, as defined by JavaScript, is:</p>
<ul>
<li>The base class fields are initialized</li>
<li>The base class constructor runs</li>
<li>The derived class fields are initialized</li>
<li>The derived class constructor runs</li>
</ul>
<p>This means that the base class constructor saw its own value for <code>name</code> during its own constructor, because the derived class field initializations hadn't run yet.</p>
<h4 id="inheriting-built-in-types"><a href="#inheriting-built-in-types">Inheriting Built-in Types</h4></a>
<blockquote>
  <p>Note: If you don't plan to inherit from built-in types like <code>Array</code>, <code>Error</code>, <code>Map</code>, etc., you may skip this section</p>
</blockquote>
<p>In ES2015, constructors which return an object implicitly substitute the value of <code>this</code> for any callers of <code>super(...)</code>.
It is necessary for generated constructor code to capture any potential return value of <code>super(...)</code> and replace it with <code>this</code>.</p>
<p>As a result, subclassing <code>Error</code>, <code>Array</code>, and others may no longer work as expected.
This is due to the fact that constructor functions for <code>Error</code>, <code>Array</code>, and the like use ECMAScript 6's <code>new.target</code> to adjust the prototype chain;
however, there is no way to ensure a value for <code>new.target</code> when invoking a constructor in ECMAScript 5.
Other downlevel compilers generally have the same limitation by default.</p>
<p>For a subclass like the following:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">FooError</span></span> <span class="tm-kw">extends</span> Error {
    <span class="tm-kw">constructor</span>(<span class="tm-vr">m</span>: <span class="tm-typ">string</span>) {
        <span class="tm-kw">super</span>(<span class="tm-vr">m</span>);
    }
    <span class="tm-mth">sayHello</span>() {
        <span class="tm-kw">return</span> <span class="tm-str">"hello "</span> + <span class="tm-kw">this</span>.<span class="tm-vr">message</span>;
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20FooError%20extends%20Error%20%7B%0A%20%20%20%20constructor(m%3A%20string)%20%7B%0A%20%20%20%20%20%20%20%20super(m)%3B%0A%20%20%20%20%7D%0A%20%20%20%20sayHello()%20%7B%0A%20%20%20%20%20%20%20%20return%20%22hello%20%22%20%2B%20this.message%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>you may find that:</p>
<ul>
<li>methods may be <code>undefined</code> on objects returned by constructing these subclasses, so calling <code>sayHello</code> will result in an error.</li>
<li><code>instanceof</code> will be broken between instances of the subclass and their instances, so <code>(new FooError()) instanceof FooError</code> will return <code>false</code>.</li>
</ul>
<p>As a recommendation, you can manually adjust the prototype immediately after any <code>super(...)</code> calls.</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">FooError</span></span> <span class="tm-kw">extends</span> Error {
    <span class="tm-kw">constructor</span>(<span class="tm-vr">m</span>: <span class="tm-typ">string</span>) {
        <span class="tm-kw">super</span>(<span class="tm-vr">m</span>);

        <span class="tm-cmt">// Set the prototype explicitly.</span>
        <span class="tm-typ">Object</span>.<span class="tm-mth">setPrototypeOf</span>(<span class="tm-kw">this</span>, <span class="tm-typ"><span class="className">FooError</span></span>.<span class="tm-vr">prototype</span>);
    }

    <span class="tm-mth">sayHello</span>() {
        <span class="tm-kw">return</span> <span class="tm-str">"hello "</span> + <span class="tm-kw">this</span>.<span class="tm-vr">message</span>;
    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20FooError%20extends%20Error%20%7B%0A%20%20%20%20constructor(m%3A%20string)%20%7B%0A%20%20%20%20%20%20%20%20super(m)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20Set%20the%20prototype%20explicitly.%0A%20%20%20%20%20%20%20%20Object.setPrototypeOf(this%2C%20FooError.prototype)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20sayHello()%20%7B%0A%20%20%20%20%20%20%20%20return%20%22hello%20%22%20%2B%20this.message%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>However, any subclass of <code>FooError</code> will have to manually set the prototype as well.
For runtimes that don't support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf</code></a>, you may instead be able to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>.</p>
<p>Unfortunately, <a href="https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx">these workarounds will not work on Internet Explorer 10 and prior</a>.
One can manually copy methods from the prototype onto the instance itself (i.e. <code>FooError.prototype</code> onto <code>this</code>), but the prototype chain itself cannot be fixed.</p>
<h2 id="member-visibility"><a href="#member-visibility">Member Visibility</h2></a>
<p>You can use TypeScript to control whether certain methods or properties are visible to code outside the class.</p>
<h3 id="public"><a href="#public"><code>public</code></h3></a>
<p>The default visibility of class members is <code>public</code>.
A <code>public</code> member can be accessed by anywhere:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Greeter</span></span> {
  <span class="tm-kw">public</span> <span class="tm-mth">greet</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"hi!"</span>);
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">g</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Greeter</span></span>();
<span class="tm-vr">g</span>.<span class="tm-mth">greet</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Greeter%20%7B%0A%20%20public%20greet()%20%7B%0A%20%20%20%20console.log(%22hi!%22)%3B%0A%20%20%7D%0A%7D%0Aconst%20g%20%3D%20new%20Greeter()%3B%0Ag.greet()%3B">Try</a></pre></p>
<p>Because <code>public</code> is already the default visibility modifier, you don't ever <em>need</em> to write it on a class member, but might choose to do so for style/readability reasons.</p>
<h3 id="protected"><a href="#protected"><code>protected</code></h3></a>
<p><code>protected</code> members are only visible to subclasses of the class they're declared in.</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Greeter</span></span> {
  <span class="tm-kw">public</span> <span class="tm-mth">greet</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-kw">this</span>.<span class="tm-mth">getName</span>());
  }
  <span class="tm-kw">protected</span> <span class="tm-mth">getName</span>() {
    <span class="tm-kw">return</span> <span class="tm-str">"hi"</span>;
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">SpecialGreeter</span></span> <span class="tm-kw">extends</span> <span class="className">Greeter</span> {
  <span class="tm-kw">public</span> <span class="tm-mth">howdy</span>() {
    <span class="tm-cmt">// OK to access protected member here</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Howdy, "</span> + <span class="highlight"><span class="highlight-content"></span><span class="highlight-description"></span><span class="tm-kw">this</span>.<span class="tm-mth">getName</span>()</span>);
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">g</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">SpecialGreeter</span></span>();
<span class="tm-vr">g</span>.<span class="tm-mth">greet</span>(); <span class="tm-cmt">// OK</span>
<span class="tm-vr">g</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2445-334-7"><span class="error-highlight"></span><span class="tm-mth">getName</span><span id="errLabel-2445-334-7" role="tooltip" class="error-tooltip">Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.</span></span>();<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Greeter%20%7B%0A%20%20public%20greet()%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20this.getName())%3B%0A%20%20%7D%0A%20%20protected%20getName()%20%7B%0A%20%20%20%20return%20%22hi%22%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20SpecialGreeter%20extends%20Greeter%20%7B%0A%20%20public%20howdy()%20%7B%0A%20%20%20%20%2F%2F%20OK%20to%20access%20protected%20member%20here%0A%20%20%20%20console.log(%22Howdy%2C%20%22%20%2B%20this.getName())%3B%0A%20%20%7D%0A%7D%0Aconst%20g%20%3D%20new%20SpecialGreeter()%3B%0Ag.greet()%3B%20%2F%2F%20OK%0Ag.getName()%3B">Try</a></pre></p>
<h4 id="exposure-of-protected-members"><a href="#exposure-of-protected-members">Exposure of <code>protected</code> members</h4></a>
<p>Derived classes need to follow their base class contracts, but may choose to expose a more general type with more capabilities.
This includes making <code>protected</code> members <code>public</code>:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-kw">protected</span> <span class="tm-vr">m</span> = <span class="tm-num">10</span>;
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-cmt">// No modifier, so default is 'public'</span>
  <span class="tm-vr">m</span> = <span class="tm-num">15</span>;
}
<span class="tm-kw">const</span> <span class="tm-vr">d</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Derived</span></span>();
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">d</span>.<span class="tm-vr">m</span>); <span class="tm-cmt">// OK</span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20protected%20m%20%3D%2010%3B%0A%7D%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20%2F%2F%20No%20modifier%2C%20so%20default%20is%20'public'%0A%20%20m%20%3D%2015%3B%0A%7D%0Aconst%20d%20%3D%20new%20Derived()%3B%0Aconsole.log(d.m)%3B%20%2F%2F%20OK">Try</a></pre></p>
<p>Note that <code>Derived</code> was already able to freely read and write <code>m</code>, so this doesn't meaningfully alter the "security" of this situation.
The main thing to note here is that in the derived class, we need to be careful to repeat the <code>protected</code> modifier if this exposure isn't intentional.</p>
<h4 id="cross-hierarchy-protected-access"><a href="#cross-hierarchy-protected-access">Cross-hierarchy <code>protected</code> access</h4></a>
<p>Different OOP languages disagree about whether it's legal to access a <code>protected</code> member through a base class reference:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
    <span class="tm-kw">protected</span> <span class="tm-vr">x</span>: <span class="tm-typ">number</span> = <span class="tm-num">1</span>;
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived1</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
    <span class="tm-kw">protected</span> <span class="tm-vr">x</span>: <span class="tm-typ">number</span> = <span class="tm-num">5</span>;
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived2</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
    <span class="tm-mth">f1</span>(<span class="tm-vr">other</span>: <span class="tm-typ"><span class="className">Derived2</span></span>) {
        <span class="tm-vr">other</span>.<span class="tm-vr">x</span> = <span class="tm-num">10</span>;
    }
    <span class="tm-mth">f2</span>(<span class="tm-vr">other</span>: <span class="tm-typ"><span class="className">Base</span></span>) {
        <span class="tm-vr">other</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2446-225-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2446-225-1" role="tooltip" class="error-tooltip">Property 'x' is protected and only accessible through an instance of class 'Derived2'.</span></span> = <span class="tm-num">10</span>;
    }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'x' is protected and only accessible through an instance of class 'Derived2'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20%20%20protected%20x%3A%20number%20%3D%201%3B%0A%7D%0Aclass%20Derived1%20extends%20Base%20%7B%0A%20%20%20%20protected%20x%3A%20number%20%3D%205%3B%0A%7D%0Aclass%20Derived2%20extends%20Base%20%7B%0A%20%20%20%20f1(other%3A%20Derived2)%20%7B%0A%20%20%20%20%20%20%20%20other.x%20%3D%2010%3B%0A%20%20%20%20%7D%0A%20%20%20%20f2(other%3A%20Base)%20%7B%0A%20%20%20%20%20%20%20%20other.x%20%3D%2010%3B%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<p>Java, for example, considers this to be legal.
On the other hand, C# and C++ chose that this code should be illegal.</p>
<p>TypeScript sides with C# and C++ here, because accessing <code>x</code> in <code>Derived2</code> should only be legal from <code>Derived2</code>'s subclasses, and <code>Derived1</code> isn't one of them.
Moreover, if accessing <code>x</code> through a <code>Derived2</code> reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.</p>
<p>See also <a href="https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/">Why Can’t I Access A Protected Member From A Derived Class?</a> which explains more of C#'s reasoning.</p>
<h3 id="private"><a href="#private"><code>private</code></h3></a>
<p><code>private</code> is like <code>protected</code>, but doesn't allow access to the member even from subclasses:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-kw">private</span> <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
}
<span class="tm-kw">const</span> <span class="tm-vr">b</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Base</span></span>();
<span class="tm-cmt">// Can't access from outside the class</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">b</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2341-107-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2341-107-1" role="tooltip" class="error-tooltip">Property 'x' is private and only accessible within class 'Base'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'x' is private and only accessible within class 'Base'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20private%20x%20%3D%200%3B%0A%7D%0Aconst%20b%20%3D%20new%20Base()%3B%0A%2F%2F%20Can't%20access%20from%20outside%20the%20class%0Aconsole.log(b.x)%3B">Try</a></pre></p>
<p><pre class="typescript-code">
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-mth">showX</span>() {
    <span class="tm-cmt">// Can't access in subclasses</span>
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-kw">this</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2341-134-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2341-134-1" role="tooltip" class="error-tooltip">Property 'x' is private and only accessible within class 'Base'.</span></span>);
  }
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'x' is private and only accessible within class 'Base'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20private%20x%20%3D%200%3B%0A%7D%0A%2F%2Fcut%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20showX()%20%7B%0A%20%20%20%20%2F%2F%20Can't%20access%20in%20subclasses%0A%20%20%20%20console.log(this.x)%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Because <code>private</code> members aren't visible to derived classes, a derived class can't increase its visibility:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-kw">private</span> <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
}
<span class="tm-kw">class</span> <span class="error" tabindex="0" aria-describedby="errLabel-2415-38-7"><span class="error-highlight"></span><span class="tm-typ"><span class="className">Derived</span></span><span id="errLabel-2415-38-7" role="tooltip" class="error-tooltip">Class 'Derived' incorrectly extends base class 'Base'.
  Property 'x' is private in type 'Base' but not in type 'Derived'.</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-vr">x</span> = <span class="tm-num">1</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Class 'Derived' incorrectly extends base class 'Base'.</div><div class="error-line"><div class="indent"></div>Property 'x' is private in type 'Base' but not in type 'Derived'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20private%20x%20%3D%200%3B%0A%7D%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20x%20%3D%201%3B%0A%7D">Try</a></pre></p>
<h4 id="cross-instance-private-access"><a href="#cross-instance-private-access">Cross-instance <code>private</code> access</h4></a>
<p>Different OOP languages disagree about whether different instances of the same class may access each others' <code>private</code> members.
While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.</p>
<p>TypeScript does allow cross-instance <code>private</code> access:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">A</span></span> {
  <span class="tm-kw">private</span> <span class="tm-vr">x</span> = <span class="tm-num">10</span>;

  <span class="tm-kw">public</span> <span class="tm-mth">sameAs</span>(<span class="tm-vr">other</span>: <span class="tm-typ"><span class="className">A</span></span>) {
    <span class="tm-cmt">// No error</span>
    <span class="tm-kw">return</span> <span class="tm-vr">other</span>.<span class="tm-vr">x</span> === <span class="tm-kw">this</span>.<span class="tm-vr">x</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20A%20%7B%0A%20%20private%20x%20%3D%2010%3B%0A%0A%20%20public%20sameAs(other%3A%20A)%20%7B%0A%20%20%20%20%2F%2F%20No%20error%0A%20%20%20%20return%20other.x%20%3D%3D%3D%20this.x%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<h4 id="private-and-runtime-privacy"><a href="#private-and-runtime-privacy">Caveats</h4></a>
<p>Like other aspects of TypeScript's type system, <code>private</code> and <code>protected</code> are only enforced during type checking.
This means that JavaScript runtime constructs like <code>in</code> or simple property lookup can still access a <code>private</code> or <code>protected</code> member:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MySafe</span></span> {
  <span class="tm-kw">private</span> <span class="tm-vr">secretKey</span> = <span class="tm-num">12345</span>;
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MySafe%20%7B%0A%20%20private%20secretKey%20%3D%2012345%3B%0A%7D">Try</a></pre></p>
<p><pre class="typescript-code"><span class="tm-cmt">// In a JavaScript file...</span>
<span class="tm-kw">const</span> <span class="tm-vr">s</span> = <span class="tm-kw">new</span> <span class="tm-typ">MySafe</span>();
<span class="tm-cmt">// Will print 12345</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">s</span>.<span class="tm-vr">secretKey</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20In%20a%20JavaScript%20file...%0Aconst%20s%20%3D%20new%20MySafe()%3B%0A%2F%2F%20Will%20print%2012345%0Aconsole.log(s.secretKey)%3B">Try</a></pre></p>
<p>If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, weak maps, or private fields.</p>
<h2 id="static-members"><a href="#static-members">Static Members</h2></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">Background Reading: Static Members (MDN)</a></p>
  </aside>
<p>Classes may have <code>static</code> members.
These members aren't associated with a particular instance of the class.
They can be accessed through the class constructor object itself:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  <span class="tm-kw">static</span> <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
  <span class="tm-kw">static</span> <span class="tm-mth">printX</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr"><span class="className">MyClass</span></span>.<span class="tm-vr">x</span>);
  }
}
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr"><span class="className">MyClass</span></span>.<span class="tm-vr">x</span>);
<span class="tm-vr"><span class="className">MyClass</span></span>.<span class="tm-mth">printX</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20static%20x%20%3D%200%3B%0A%20%20static%20printX()%20%7B%0A%20%20%20%20console.log(MyClass.x)%3B%0A%20%20%7D%0A%7D%0Aconsole.log(MyClass.x)%3B%0AMyClass.printX()%3B">Try</a></pre></p>
<p>Static members can also use the same <code>public</code>, <code>protected</code>, and <code>private</code> visibility modifiers:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  <span class="tm-kw">private</span> <span class="tm-kw">static</span> <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
}
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr"><span class="className">MyClass</span></span>.<span class="error" tabindex="0" aria-describedby="errLabel-2341-62-1"><span class="error-highlight"></span><span class="tm-vr">x</span><span id="errLabel-2341-62-1" role="tooltip" class="error-tooltip">Property 'x' is private and only accessible within class 'MyClass'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'x' is private and only accessible within class 'MyClass'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20private%20static%20x%20%3D%200%3B%0A%7D%0Aconsole.log(MyClass.x)%3B">Try</a></pre></p>
<p>Static members are also inherited:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-kw">static</span> <span class="tm-mth">getGreeting</span>() {
    <span class="tm-kw">return</span> <span class="tm-str">"Hello world"</span>;
  }
}
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-vr">myGreeting</span> = <span class="tm-vr"><span class="className">Derived</span></span>.<span class="tm-mth">getGreeting</span>();
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Base%20%7B%0A%20%20static%20getGreeting()%20%7B%0A%20%20%20%20return%20%22Hello%20world%22%3B%0A%20%20%7D%0A%7D%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20myGreeting%20%3D%20Derived.getGreeting()%3B%0A%7D">Try</a></pre></p>
<h3 id="special-static-names"><a href="#special-static-names">Special Static Names</h3></a>
<p>It's generally not safe/possible to overwrite properties from the <code>Function</code> prototype.
Because classes are themselves functions that can be invoked with <code>new</code>, certain <code>static</code> names can't be used.
Function properties like <code>name</code>, <code>length</code>, and <code>call</code> aren't valid to define as <code>static</code> members:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">S</span></span> {
  <span class="tm-kw">static</span> <span class="error" tabindex="0" aria-describedby="errLabel-2699-19-4"><span class="error-highlight"></span><span class="tm-vr">name</span><span id="errLabel-2699-19-4" role="tooltip" class="error-tooltip">Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.</span></span> = <span class="tm-str">"S!"</span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20S%20%7B%0A%20%20static%20name%20%3D%20%22S!%22%3B%0A%7D">Try</a></pre></p>
<h3 id="why-no-static-classes"><a href="#why-no-static-classes">Why No Static Classes?</h3></a>
<p>TypeScript (and JavaScript) don't have a construct called <code>static class</code> the same way C# and Java do.</p>
<p>Those constructs <em>only</em> exist because those languages force all data and functions to be inside a class; because that restriction doesn't exist in TypeScript, there's no need for them.
A class with only a single instance is typically just represented as a normal <em>object</em> in JavaScript/TypeScript.</p>
<p>For example, we don't need a "static class" syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:</p>
<p><pre class="typescript-code"><span class="tm-cmt">// Unnecessary "static" class</span>
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyStaticClass</span></span> {
    <span class="tm-kw">static</span> <span class="tm-mth">doSomething</span>() {

    }
}

<span class="tm-cmt">// Preferred (alternative 1)</span>
<span class="tm-kw">function</span> <span class="tm-mth">doSomething</span>() {

}

<span class="tm-cmt">// Preferred (alternative 2)</span>
<span class="tm-kw">const</span> <span class="tm-vr">MyHelperObject</span> = {
    <span class="tm-mth">dosomething</span>() {

    }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20Unnecessary%20%22static%22%20class%0Aclass%20MyStaticClass%20%7B%0A%20%20%20%20static%20doSomething()%20%7B%0A%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Preferred%20(alternative%201)%0Afunction%20doSomething()%20%7B%0A%0A%7D%0A%0A%2F%2F%20Preferred%20(alternative%202)%0Aconst%20MyHelperObject%20%3D%20%7B%0A%20%20%20%20dosomething()%20%7B%0A%0A%20%20%20%20%7D%0A%7D">Try</a></pre></p>
<h2 id="generic-classes"><a href="#generic-classes">Generic Classes</h2></a>
<p>Classes, much like interfaces, can be generic.
When a generic class is instantiated with <code>new</code>, its type parameters are inferred the same way as in a function call:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Box</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> {
  <span class="tm-vr">contents</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>;
  <span class="tm-kw">constructor</span>(<span class="tm-vr">value</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) {
    <span class="tm-kw">this</span>.<span class="tm-vr">contents</span> = <span class="tm-vr">value</span>;
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">b</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Box</span></span>(<span class="tm-str">"hello!"</span>);
      <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">const</span><span class="space"> </span><span class="localName">b</span><span class="punctuation">:</span><span class="space"> </span><span class="className">Box</span><span class="punctuation"><</span><span class="keyword">string</span><span class="punctuation">></span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%3CT%3E%20%7B%0A%20%20contents%3A%20T%3B%0A%20%20constructor(value%3A%20T)%20%7B%0A%20%20%20%20this.contents%20%3D%20value%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20b%20%3D%20new%20Box(%22hello!%22)%3B">Try</a></pre></p>
<p>Classes can use generic constraints and defaults the same way as interfaces.</p>
<h3 id="type-parameters-in-static-members"><a href="#type-parameters-in-static-members">Type Parameters in Static Members</h3></a>
<p>This code isn't legal, and it may not be obvious why:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Box</span></span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> {
  <span class="tm-kw">static</span> <span class="tm-vr">defaultValue</span>: <span class="error" tabindex="0" aria-describedby="errLabel-2302-38-1"><span class="error-highlight"></span><span class="tm-typ">T</span><span id="errLabel-2302-38-1" role="tooltip" class="error-tooltip">Static members cannot reference class type parameters.</span></span>;
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Static members cannot reference class type parameters.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%3CT%3E%20%7B%0A%20%20static%20defaultValue%3A%20T%3B%0A%7D">Try</a></pre></p>
<p>Remember that types are always fully erased!
At runtime, there's only <em>one</em> <code>Box.defaultValue</code> property slot.
This means that setting <code>Box&lt;string&gt;.defaultValue</code> (if that were possible) would <em>also</em> change <code>Box&lt;number&gt;.defaultValue</code> - not good.
The <code>static</code> members of a generic class can never refer to the class's type parameters.</p>
<h2 id="runtime-this-in-classes"><a href="#runtime-this-in-classes"><code>this</code> at Runtime in Classes</h2></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">Background Reading: <code>this</code> keyword (MDN)</a></p>
  </aside>
<p>It's important to remember that TypeScript doesn't change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.</p>
<p>JavaScript's handling of <code>this</code> is indeed unusual:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  <span class="tm-vr">name</span> = <span class="tm-str">"MyClass"</span>;
  <span class="tm-mth">getName</span>() {
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>.<span class="tm-vr">name</span>;
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">c</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">MyClass</span></span>();
<span class="tm-kw">const</span> <span class="tm-vr">obj</span> = {
  <span class="tm-vr">name:</span> <span class="tm-str">"obj"</span>,
  <span class="tm-vr">getName:</span> <span class="tm-vr">c</span>.<span class="tm-vr">getName</span>
};

<span class="tm-cmt">// Prints "obj", not "MyClass"</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">obj</span>.<span class="tm-mth">getName</span>());<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20name%20%3D%20%22MyClass%22%3B%0A%20%20getName()%20%7B%0A%20%20%20%20return%20this.name%3B%0A%20%20%7D%0A%7D%0Aconst%20c%20%3D%20new%20MyClass()%3B%0Aconst%20obj%20%3D%20%7B%0A%20%20name%3A%20%22obj%22%2C%0A%20%20getName%3A%20c.getName%0A%7D%3B%0A%0A%2F%2F%20Prints%20%22obj%22%2C%20not%20%22MyClass%22%0Aconsole.log(obj.getName())%3B">Try</a></pre></p>
<p>Long story short, by default, the value of <code>this</code> inside a function depends on <em>how the function was called</em>.
In this example, because the function was called through the <code>obj</code> reference, its value of <code>this</code> was <code>obj</code> rather than the class instance.</p>
<p>This is rarely what you want to happen!
TypeScript provides some ways to mitigate or prevent this kind of error.</p>
<h3 id="arrow-functions"><a href="#arrow-functions">Arrow Functions</h3></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Background Reading: Arrow functions (MDN)</a></p>
  </aside>
<p>If you have a function that will often be called in a way that loses its <code>this</code> context, it can make sense to use an arrow function property instead of a method definition:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  <span class="tm-vr">name</span> = <span class="tm-str">"MyClass"</span>;
  <span class="tm-mth">getName</span> = () <span class="tm-kw">=></span> {
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>.<span class="tm-vr">name</span>;
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">c</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">MyClass</span></span>();
<span class="tm-kw">const</span> <span class="tm-vr">g</span> = <span class="tm-vr">c</span>.<span class="tm-vr">getName</span>;
<span class="tm-cmt">// Prints "MyClass" instead of crashing</span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-mth">g</span>());<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20name%20%3D%20%22MyClass%22%3B%0A%20%20getName%20%3D%20()%20%3D%3E%20%7B%0A%20%20%20%20return%20this.name%3B%0A%20%20%7D%0A%7D%0Aconst%20c%20%3D%20new%20MyClass()%3B%0Aconst%20g%20%3D%20c.getName%3B%0A%2F%2F%20Prints%20%22MyClass%22%20instead%20of%20crashing%0Aconsole.log(g())%3B">Try</a></pre></p>
<p>This has some trade-offs:</p>
<ul>
<li>The <code>this</code> value is guaranteed to be correct at runtime, even for code not checked with TypeScript</li>
<li>This will use more memory, because each class instance will have its own copy of each function defined this way</li>
<li>You can't use <code>super.getName</code> in a derived class, because there's no entry in the prototype chain to fetch the base class method from</li>
</ul>
<h3 id="this-parameters"><a href="#this-parameters"><code>this</code> parameters</h3></a>
<p>In a method or function definition, an initial parameter named <code>this</code> has special meaning in TypeScript.
These parameters are erased during compilation:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// TypeScript input with 'this' parameter</span>
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">this</span>: <span class="tm-typ"><span class="typeAliasName">SomeType</span></span>, <span class="tm-vr">x</span>: <span class="tm-typ">number</span>) {
  <span class="tm-cmt">/* ... */</span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=type%20SomeType%20%3D%20any%0A%2F%2Fcut%0A%2F%2F%20TypeScript%20input%20with%20'this'%20parameter%0Afunction%20fn(this%3A%20SomeType%2C%20x%3A%20number)%20%7B%0A%20%20%2F*%20...%20*%2F%0A%7D">Try</a></pre>
<pre class="typescript-code"><span class="tm-cmt">// JavaScript output</span>
<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>) {
  <span class="tm-cmt">/* ... */</span>
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=%2F%2F%20JavaScript%20output%0Afunction%20fn(x)%20%7B%0A%20%20%2F*%20...%20*%2F%0A%7D">Try</a></pre></p>
<p>TypeScript checks that calling a function with a <code>this</code> parameter is done so with a correct context.
Instead of using an arrow function, we can add a <code>this</code> parameter to method definitions to statically enforce that the method is called correctly:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">MyClass</span></span> {
  <span class="tm-vr">name</span> = <span class="tm-str">"MyClass"</span>;
  <span class="tm-mth">getName</span>(<span class="tm-vr">this</span>: <span class="tm-typ"><span class="className">MyClass</span></span>) {
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>.<span class="tm-vr">name</span>;
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">c</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">MyClass</span></span>();
<span class="tm-cmt">// OK</span>
<span class="tm-vr">c</span>.<span class="tm-mth">getName</span>();

<span class="tm-cmt">// Error, would crash</span>
<span class="tm-kw">const</span> <span class="tm-vr">g</span> = <span class="tm-vr">c</span>.<span class="tm-vr">getName</span>;
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2684-191-3"><span class="error-highlight"></span><span class="tm-mth">g</span>()<span id="errLabel-2684-191-3" role="tooltip" class="error-tooltip">The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20MyClass%20%7B%0A%20%20name%20%3D%20%22MyClass%22%3B%0A%20%20getName(this%3A%20MyClass)%20%7B%0A%20%20%20%20return%20this.name%3B%0A%20%20%7D%0A%7D%0Aconst%20c%20%3D%20new%20MyClass()%3B%0A%2F%2F%20OK%0Ac.getName()%3B%0A%0A%2F%2F%20Error%2C%20would%20crash%0Aconst%20g%20%3D%20c.getName%3B%0Aconsole.log(g())%3B">Try</a></pre></p>
<p>This method takes the opposite trade-offs of the arrow function approach:</p>
<ul>
<li>JavaScript callers might still use the class method incorrectly without realizing it</li>
<li>Only one function per class definition gets allocated, rather than one per class instance</li>
<li>Base method definitions can still be called via <code>super.</code></li>
</ul>
<h2 id="this-types"><a href="#this-types"><code>this</code> Types</h2></a>
<p>In classes, a special type called <code>this</code> refers <em>dynamically</em> to the type of the current class.
Let's see how this is useful:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Box</span></span> {
  <span class="tm-vr">contents</span>: <span class="tm-typ">string</span> = <span class="tm-str">""</span>;
  <span class="tm-mth">set</span>(<span class="tm-vr">value</span>: <span class="tm-typ">string</span>) {
   <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">method</span><span class="punctuation">)</span><span class="space"> </span><span class="className">Box</span><span class="punctuation">.</span><span class="methodName">set</span><span class="punctuation">(</span><span class="parameterName">value</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">string</span><span class="punctuation">)</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">this</span></span>
    <span class="tm-kw">this</span>.<span class="tm-vr">contents</span> = <span class="tm-vr">value</span>;
    <span class="tm-kw">return</span> <span class="tm-kw">this</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%20%7B%0A%20%20contents%3A%20string%20%3D%20%22%22%3B%0A%20%20set(value%3A%20string)%20%7B%0A%20%20%20%20this.contents%20%3D%20value%3B%0A%20%20%20%20return%20this%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>Here, TypeScript inferred the return type of <code>set</code> to be <code>this</code>, rather than <code>Box</code>.
Now let's make a subclass of <code>Box</code>:</p>
<p><pre class="typescript-code">
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">ClearableBox</span></span> <span class="tm-kw">extends</span> <span class="className">Box</span> {
  <span class="tm-mth">clear</span>() {
    <span class="tm-kw">this</span>.<span class="tm-vr">contents</span> = <span class="tm-str">""</span>;
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">a</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">ClearableBox</span></span>();
<span class="tm-kw">const</span> <span class="tm-vr">b</span> = <span class="tm-vr">a</span>.<span class="tm-mth">set</span>(<span class="tm-str">"hello"</span>);
      <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">const</span><span class="space"> </span><span class="localName">b</span><span class="punctuation">:</span><span class="space"> </span><span class="className">ClearableBox</span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%20%7B%0A%20%20contents%3A%20string%20%3D%20%22%22%3B%0A%20%20set(value%3A%20string)%20%7B%0A%20%20%20%20this.contents%20%3D%20value%3B%0A%20%20%20%20return%20this%3B%0A%20%20%7D%0A%7D%0A%2F%2Fcut%0Aclass%20ClearableBox%20extends%20Box%20%7B%0A%20%20clear()%20%7B%0A%20%20%20%20this.contents%20%3D%20%22%22%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20a%20%3D%20new%20ClearableBox()%3B%0Aconst%20b%20%3D%20a.set(%22hello%22)%3B">Try</a></pre></p>
<p>You can also use <code>this</code> in a parameter type annotation:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Box</span></span> {
  <span class="tm-vr">content</span>: <span class="tm-typ">string</span> = <span class="tm-str">""</span>;
  <span class="tm-mth">sameAs</span>(<span class="tm-vr">other</span>: <span class="tm-typ">this</span>) {
    <span class="tm-kw">return</span> <span class="tm-vr">other</span>.<span class="tm-vr">content</span> === <span class="tm-kw">this</span>.<span class="tm-vr">content</span>;
  }
}<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%20%7B%0A%20%20content%3A%20string%20%3D%20%22%22%3B%0A%20%20sameAs(other%3A%20this)%20%7B%0A%20%20%20%20return%20other.content%20%3D%3D%3D%20this.content%3B%0A%20%20%7D%0A%7D">Try</a></pre></p>
<p>This is different from writing <code>other: Box</code> -- if you have a derived class, its <code>sameAs</code> method will now only accept other instances of that same derived class:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Box</span></span> {
  <span class="tm-vr">content</span>: <span class="tm-typ">string</span> = <span class="tm-str">""</span>;
  <span class="tm-mth">sameAs</span>(<span class="tm-vr">other</span>: <span class="tm-typ">this</span>) {
    <span class="tm-kw">return</span> <span class="tm-vr">other</span>.<span class="tm-vr">content</span> === <span class="tm-kw">this</span>.<span class="tm-vr">content</span>;
  }
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">DerivedBox</span></span> <span class="tm-kw">extends</span> <span class="className">Box</span>  {
  <span class="tm-vr">otherContent</span>: <span class="tm-typ">string</span> = <span class="tm-str">"?"</span>;
}

<span class="tm-kw">const</span> <span class="tm-vr">base</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Box</span></span>();
<span class="tm-kw">const</span> <span class="tm-vr">derived</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">DerivedBox</span></span>();
<span class="tm-vr">derived</span>.<span class="tm-mth">sameAs</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-248-4"><span class="error-highlight"></span><span class="tm-vr">base</span><span id="errLabel-2345-248-4" role="tooltip" class="error-tooltip">Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.</div><div class="error-line"><div class="indent"></div>Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Box%20%7B%0A%20%20content%3A%20string%20%3D%20%22%22%3B%0A%20%20sameAs(other%3A%20this)%20%7B%0A%20%20%20%20return%20other.content%20%3D%3D%3D%20this.content%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20DerivedBox%20extends%20Box%20%20%7B%0A%20%20otherContent%3A%20string%20%3D%20%22%3F%22%3B%0A%7D%0A%0Aconst%20base%20%3D%20new%20Box()%3B%0Aconst%20derived%20%3D%20new%20DerivedBox()%3B%0Aderived.sameAs(base)%3B">Try</a></pre></p>
<h2 id="parameter-properties"><a href="#parameter-properties">Parameter Properties</h2></a>
<p>TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value.
These are called <em>parameter properties</em> and are created by prefixing a constructor argument with one of the visibility modifiers <code>public</code>, <code>private</code>, <code>protected</code>, or <code>readonly</code>.
The resulting field gets those modifier(s):</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">A</span></span> {
  <span class="tm-kw">constructor</span> (<span class="tm-kw">public</span> <span class="tm-vr">readonly</span> <span class="tm-vr">x</span>: <span class="tm-typ">number</span>, <span class="tm-kw">protected</span> <span class="tm-vr">y</span>: <span class="tm-typ">number</span>, <span class="tm-kw">private</span> <span class="tm-vr">z</span>: <span class="tm-typ">number</span>) {
    <span class="tm-cmt">// No body necessary</span>
  }
}
<span class="tm-kw">const</span> <span class="tm-vr">a</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">A</span></span>(<span class="tm-num">1</span>, <span class="tm-num">2</span>, <span class="tm-num">3</span>);
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span>.<span class="tm-vr">x</span>);
              <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="punctuation">(</span><span class="text">property</span><span class="punctuation">)</span><span class="space"> </span><span class="className">A</span><span class="punctuation">.</span><span class="propertyName">x</span><span class="punctuation">:</span><span class="space"> </span><span class="keyword">number</span></span>
<span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-vr">a</span>.<span class="error" tabindex="0" aria-describedby="errLabel-2341-183-1"><span class="error-highlight"></span><span class="tm-vr">z</span><span id="errLabel-2341-183-1" role="tooltip" class="error-tooltip">Property 'z' is private and only accessible within class 'A'.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Property 'z' is private and only accessible within class 'A'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20A%20%7B%0A%20%20constructor%20(public%20readonly%20x%3A%20number%2C%20protected%20y%3A%20number%2C%20private%20z%3A%20number)%20%7B%0A%20%20%20%20%2F%2F%20No%20body%20necessary%0A%20%20%7D%0A%7D%0Aconst%20a%20%3D%20new%20A(1%2C%202%2C%203)%3B%0Aconsole.log(a.x)%3B%0Aconsole.log(a.z)%3B">Try</a></pre></p>
<h2 id="class-expressions"><a href="#class-expressions">Class Expressions</h2></a>
<aside>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class">Background reading: Class expressions (MDN)</a></p>
  </aside>
<p>Class expressions are very similar to class declarations.
The only real difference is that class expressions don't need a name, though we can refer to them via whatever identifier they ended up bound to:</p>
<p><pre class="typescript-code"><span class="tm-kw">const</span> <span class="tm-vr">someClass</span> = <span class="tm-kw">class</span><<span class="tm-typ"><span class="typeParameterName">T</span></span>> {
  <span class="tm-vr">content</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>;
  <span class="tm-kw">constructor</span>(<span class="tm-vr">value</span>: <span class="tm-typ"><span class="typeParameterName">T</span></span>) {
    <span class="tm-kw">this</span>.<span class="tm-vr">content</span> = <span class="tm-vr">value</span>;
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">m</span> = <span class="tm-kw">new</span> <span class="tm-typ">someClass</span>(<span class="tm-str">"Hello, world"</span>);
      <span class="quickinfo-result"><span class="quickinfo-arrow">▲</span><span class="keyword">const</span><span class="space"> </span><span class="localName">m</span><span class="punctuation">:</span><span class="space"> </span><span class="className">someClass</span><span class="punctuation"><</span><span class="keyword">string</span><span class="punctuation">></span></span><a class="playground-link" href="https://www.typescriptlang.org/play/#src=const%20someClass%20%3D%20class%3CT%3E%20%7B%0A%20%20content%3A%20T%3B%0A%20%20constructor(value%3A%20T)%20%7B%0A%20%20%20%20this.content%20%3D%20value%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20m%20%3D%20new%20someClass(%22Hello%2C%20world%22)%3B">Try</a></pre></p>
<h2 id="abstract-classes-and-members"><a href="#abstract-classes-and-members"><code>abstract</code> Classes and Members</h2></a>
<p>Classes, methods, and fields in TypeScript may be <em>abstract</em>.</p>
<p>An <em>abstract method</em> or <em>abstract field</em> is one that hasn't had an implementation provided.
These members must exist inside an <em>abstract class</em>, which cannot be directly instantiated.</p>
<p>The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members.
When a class doesn't have any abstract members, it is said to be <em>concrete</em>.</p>
<p>Let's look at an example</p>
<p><pre class="typescript-code"><span class="tm-kw">abstract</span> <span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Base</span></span> {
  <span class="tm-kw">abstract</span> <span class="tm-mth">getName</span>():<span class="tm-typ"> string</span>;

  <span class="tm-mth">printName</span>() {
    <span class="tm-typ">console</span>.<span class="tm-mth">log</span>(<span class="tm-str">"Hello, "</span> + <span class="tm-kw">this</span>.<span class="tm-mth">getName</span>());
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">b</span> = <span class="error" tabindex="0" aria-describedby="errLabel-2511-131-10"><span class="error-highlight"></span><span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Base</span></span>()<span id="errLabel-2511-131-10" role="tooltip" class="error-tooltip">Cannot create an instance of an abstract class.</span></span>;<hr class="error-divider"><div class="listed-error"><div class="error-line">Cannot create an instance of an abstract class.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=abstract%20class%20Base%20%7B%0A%20%20abstract%20getName()%3A%20string%3B%0A%0A%20%20printName()%20%7B%0A%20%20%20%20console.log(%22Hello%2C%20%22%20%2B%20this.getName())%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20b%20%3D%20new%20Base()%3B">Try</a></pre></p>
<p>We can't instantiate <code>Base</code> with <code>new</code> because it's abstract.
Instead, we need to make a derived class and implement the abstract members:</p>
<p><pre class="typescript-code">
<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Derived</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-mth">getName</span>() {
    <span class="tm-kw">return</span> <span class="tm-str">"world"</span>;
  }
}

<span class="tm-kw">const</span> <span class="tm-vr">d</span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Derived</span></span>();
<span class="tm-vr">d</span>.<span class="tm-mth">printName</span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=abstract%20class%20Base%20%7B%0A%20%20abstract%20getName()%3A%20string%3B%0A%20%20printName()%20%7B%20%7D%0A%7D%0A%2F%2Fcut%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20getName()%20%7B%0A%20%20%20%20return%20%22world%22%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20d%20%3D%20new%20Derived()%3B%0Ad.printName()%3B">Try</a></pre></p>
<p>Notice that if we forget to implement the base class's abstract members, we'll get an error:
<pre class="typescript-code">
<span class="tm-kw">class</span> <span class="error" tabindex="0" aria-describedby="errLabel-2515-84-7"><span class="error-highlight"></span><span class="tm-typ"><span class="className">Derived</span></span><span id="errLabel-2515-84-7" role="tooltip" class="error-tooltip">Non-abstract class 'Derived' does not implement inherited abstract member 'getName' from class 'Base'.</span></span> <span class="tm-kw">extends</span> <span class="className">Base</span> {
  <span class="tm-cmt">// forgot to do anything</span>
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Non-abstract class 'Derived' does not implement inherited abstract member 'getName' from class 'Base'.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=abstract%20class%20Base%20%7B%0A%20%20abstract%20getName()%3A%20string%3B%0A%20%20printName()%20%7B%20%7D%0A%7D%0A%2F%2Fcut%0Aclass%20Derived%20extends%20Base%20%7B%0A%20%20%2F%2F%20forgot%20to%20do%20anything%0A%7D">Try</a></pre></p>
<h3 id="abstract-construct-signatures"><a href="#abstract-construct-signatures">Abstract Construct Signatures</h3></a>
<p>Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.</p>
<p>For example, you might want to write this code:</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">ctor</span>: <span class="tm-kw">typeof</span> <span class="tm-typ"><span class="className">Base</span></span>) {
  <span class="tm-kw">const</span> <span class="tm-vr">instance</span> = <span class="error" tabindex="0" aria-describedby="errLabel-2511-188-10"><span class="error-highlight"></span><span class="tm-kw">new</span> <span class="tm-typ">ctor</span>()<span id="errLabel-2511-188-10" role="tooltip" class="error-tooltip">Cannot create an instance of an abstract class.</span></span>;
  <span class="tm-vr">instance</span>.<span class="tm-mth">printName</span>();
}<hr class="error-divider"><div class="listed-error"><div class="error-line">Cannot create an instance of an abstract class.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=abstract%20class%20Base%20%7B%0A%20%20abstract%20getName()%3A%20string%3B%0A%20%20printName()%20%7B%20%7D%0A%7D%0Aclass%20Derived%20extends%20Base%20%7B%20getName()%20%7B%20return%20%22%22%20%7D%20%7D%0A%2F%2Fcut%0Afunction%20greet(ctor%3A%20typeof%20Base)%20%7B%0A%20%20const%20instance%20%3D%20new%20ctor()%3B%0A%20%20instance.printName()%3B%0A%7D">Try</a></pre></p>
<p>TypeScript is correctly telling you that you're trying to instantiate an abstract class.
After all, given the definition of <code>greet</code>, it's perfectly legal to write this code, which would end up constructing an abstract class:</p>
<p><pre class="typescript-code">
<span class="tm-cmt">// Bad!</span>
<span class="tm-mth">greet</span>(<span class="tm-vr">Base</span>);</pre></p>
<p>Instead, you want to write a function that accepts something with a construct signature:</p>
<p><pre class="typescript-code">
<span class="tm-kw">function</span> <span class="tm-mth">greet</span>(<span class="tm-vr">ctor</span>: <span class="tm-kw">new</span>() <span class="tm-kw">=></span> <span class="tm-typ"><span class="className">Base</span></span>) {
  <span class="tm-kw">const</span> <span class="tm-vr">instance</span> = <span class="tm-kw">new</span> <span class="tm-typ">ctor</span>();
  <span class="tm-vr">instance</span>.<span class="tm-mth">printName</span>();
}
<span class="tm-mth">greet</span>(<span class="tm-vr"><span class="className">Derived</span></span>);
<span class="tm-mth">greet</span>(<span class="error" tabindex="0" aria-describedby="errLabel-2345-250-4"><span class="error-highlight"></span><span class="tm-vr"><span class="className">Base</span></span><span id="errLabel-2345-250-4" role="tooltip" class="error-tooltip">Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
  Cannot assign an abstract constructor type to a non-abstract constructor type.</span></span>);<hr class="error-divider"><div class="listed-error"><div class="error-line">Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.</div><div class="error-line"><div class="indent"></div>Cannot assign an abstract constructor type to a non-abstract constructor type.</div></div><a class="playground-link" href="https://www.typescriptlang.org/play/#src=abstract%20class%20Base%20%7B%0A%20%20abstract%20getName()%3A%20string%3B%0A%20%20printName()%20%7B%20%7D%0A%7D%0Aclass%20Derived%20extends%20Base%20%7B%20getName()%20%7B%20return%20%22%22%20%7D%20%7D%0A%2F%2Fcut%0Afunction%20greet(ctor%3A%20new()%20%3D%3E%20Base)%20%7B%0A%20%20const%20instance%20%3D%20new%20ctor()%3B%0A%20%20instance.printName()%3B%0A%7D%0Agreet(Derived)%3B%0Agreet(Base)%3B">Try</a></pre></p>
<p>Now TypeScript correctly tells you about which class constructor functions can be invoked - <code>Derived</code> can because it's concrete, but <code>Base</code> cannot.</p>
<h2 id="relationships-between-classes"><a href="#relationships-between-classes">Relationships Between Classes</h2></a>
<p>In most cases, classes in TypeScript are compared structurally, the same as other types.</p>
<p>For example, these two classes can be used in place of each other because they're identical:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point1</span></span> {
  <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
  <span class="tm-vr">y</span> = <span class="tm-num">0</span>;
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Point2</span></span> {
  <span class="tm-vr">x</span> = <span class="tm-num">0</span>;
  <span class="tm-vr">y</span> = <span class="tm-num">0</span>;
}

<span class="tm-cmt">// OK</span>
<span class="tm-kw">const</span> <span class="tm-vr">p</span>: <span class="tm-typ"><span class="className">Point1</span></span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Point2</span></span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Point1%20%7B%0A%20%20x%20%3D%200%3B%0A%20%20y%20%3D%200%3B%0A%7D%0A%0Aclass%20Point2%20%7B%0A%20%20x%20%3D%200%3B%0A%20%20y%20%3D%200%3B%0A%7D%0A%0A%2F%2F%20OK%0Aconst%20p%3A%20Point1%20%3D%20new%20Point2()%3B">Try</a></pre></p>
<p>Similarly, subtype relationships between classes exist even if there's no explicit inheritance:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Person</span></span> {
  <span class="tm-vr">name</span>: <span class="tm-typ">string</span>;
  <span class="tm-vr">age</span>: <span class="tm-typ">number</span>;
}

<span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Employee</span></span> {
  <span class="tm-vr">name</span>: <span class="tm-typ">string</span>;
  <span class="tm-vr">age</span>: <span class="tm-typ">number</span>;
  <span class="tm-vr">salary</span>: <span class="tm-typ">number</span>;
}

<span class="tm-cmt">// OK</span>
<span class="tm-kw">const</span> <span class="tm-vr">p</span>: <span class="tm-typ"><span class="className">Person</span></span> = <span class="tm-kw">new</span> <span class="tm-typ"><span class="className">Employee</span></span>();<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Person%20%7B%0A%20%20name%3A%20string%3B%0A%20%20age%3A%20number%3B%0A%7D%0A%0Aclass%20Employee%20%7B%0A%20%20name%3A%20string%3B%0A%20%20age%3A%20number%3B%0A%20%20salary%3A%20number%3B%0A%7D%0A%0A%2F%2F%20OK%0Aconst%20p%3A%20Person%20%3D%20new%20Employee()%3B">Try</a></pre></p>
<p>This sounds straightforward, but there are a few cases that seem stranger than others.</p>
<p>Empty classes have no members.
In a structural type system, a type with no members is generally a supertype of anything else.
So if you write an empty class (don't!), anything can be used in place of it:</p>
<p><pre class="typescript-code"><span class="tm-kw">class</span> <span class="tm-typ"><span class="className">Empty</span></span> { }

<span class="tm-kw">function</span> <span class="tm-mth">fn</span>(<span class="tm-vr">x</span>: <span class="tm-typ"><span class="className">Empty</span></span>) {
  <span class="tm-cmt">// can't do anything with 'x', so I won't</span>
}

<span class="tm-cmt">// All OK!</span>
<span class="tm-mth">fn</span>(<span class="tm-vr">window</span>);
<span class="tm-mth">fn</span>({ });
<span class="tm-mth">fn</span>(<span class="tm-vr">fn</span>);<a class="playground-link" href="https://www.typescriptlang.org/play/#src=class%20Empty%20%7B%20%7D%0A%0Afunction%20fn(x%3A%20Empty)%20%7B%0A%20%20%2F%2F%20can't%20do%20anything%20with%20'x'%2C%20so%20I%20won't%0A%7D%0A%0A%2F%2F%20All%20OK!%0Afn(window)%3B%0Afn(%7B%20%7D)%3B%0Afn(fn)%3B">Try</a></pre></p>
    </article>
        <script>loadSavedTheme();</script>
    </body>
    </html>